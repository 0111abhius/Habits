import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../models/timeline_entry.dart';
import '../widgets/calendar_strip.dart';
import '../widgets/habit_tracker.dart';
import '../main.dart';  // Import for getFirestore()
import 'package:intl/intl.dart';
import 'dart:async';
import '../utils/activities.dart';
import '../widgets/activity_picker.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'login_screen.dart';
import '../widgets/timeline_hour_tile.dart';

class TimelineScreen extends StatefulWidget {
  const TimelineScreen({super.key});

  @override
  State<TimelineScreen> createState() => _TimelineScreenState();
}

class _TimelineScreenState extends State<TimelineScreen> {
  DateTime selectedDate = DateTime.now();
  static const List<String> _protectedActivities = ['Sleep'];
  List<String> _activities = List.from(kDefaultActivities);

  String _displayLabel(String act) => displayActivity(act);

  List<String> _archivedActivities = []; // Activities removed from active but kept for history
  Map<String, List<String>> _subActivities = {}; // parent -> list of subs

  TimeOfDay? wakeTime;
  TimeOfDay? sleepTime;
  late final ScrollController _scrollController;
  final TextEditingController _sleepTimeController = TextEditingController();
  final TextEditingController _wakeTimeController = TextEditingController();

  double? _pendingScrollOffset;

  Set<int> _splitHours = {}; // hours that have a 30-minute split for the selected date
  // Cache of the most recently rendered entries list. This lets us re-use the
  // previous UI when the only Firestore changes are still pending writes
  // generated by this device â€“ preventing a visible full list refresh.
  List<TimelineEntry> _cachedEntries = [];

  final ValueNotifier<bool> _habitsExpandedNotifier = ValueNotifier(true);
  final ValueNotifier<bool> _showRetroNotifier = ValueNotifier(false);

  bool get _habitsExpanded => _habitsExpandedNotifier.value;
  bool get _showRetro => _showRetroNotifier.value;

  // Using a ValueNotifier means toggling the "Day fully logged" checkbox
  // only rebuilds that specific part of the UI instead of the whole timeline.
  final ValueNotifier<bool> _dayCompleteNotifier = ValueNotifier(false);

  // Convenience getter so existing read-access sites keep working.
  bool get _dayComplete => _dayCompleteNotifier.value;

  final Map<String, GlobalKey> _blockKeys = {};
  static final Map<String, double> _offsetCache = {}; // keyed by yyyy-MM-dd (selected date)
  late String _currentDateKey;

  List<String> _recentActivities = [];

  Set<String> _loggedDates = {};
  late Stream<QuerySnapshot> _currentStream;

  @override
  void initState() {
    super.initState();
    _currentDateKey = DateFormat('yyyy-MM-dd').format(selectedDate);
    _initStream();
    _scrollController = ScrollController(initialScrollOffset: _offsetCache[_currentDateKey] ?? 0)
      ..addListener(() {
        _offsetCache[_currentDateKey] = _scrollController.offset;
      });
    _loadUserSettings();
    _loadDayComplete();
    _loadLoggedDates();
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _sleepTimeController.dispose();
    _wakeTimeController.dispose();


    _pendingScrollOffset=null;
    super.dispose();
  }

  // Helper to parse 'HH:mm' strings to TimeOfDay
  TimeOfDay _parseTime(String s) {
    final parts = s.split(':');
    return TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1]));
  }

  Future<void> _reconcileSleepEntriesForSelectedDate() async {
    if (sleepTime == null || wakeTime == null) return;
    // Do not modify historical data: only reconcile for today or future
    final DateTime today = DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day);
    if (selectedDate.isBefore(today)) return;
    final userId = FirebaseAuth.instance.currentUser?.uid;
    if (userId == null) return;

    final entriesColl = getFirestore()
        .collection('timeline_entries')
        .doc(userId)
        .collection('entries');

    final dateStr = DateFormat('yyyy-MM-dd').format(selectedDate);
    final snapshot = await entriesColl.where('date', isEqualTo: dateStr).get();
    final entries = snapshot.docs.map((d) => TimelineEntry.fromFirestore(d)).toList();

    for (var hour = 0; hour < 24; hour++) {
      final shouldSleep = _isSleepHour(hour);
      final matching = entries.where((e) => e.startTime.hour == hour);
      final TimelineEntry? existing = matching.isNotEmpty ? matching.first : null;

      final start = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour);
      final id = _docId(start);

      if (shouldSleep) {
        // ensure a placeholder exists but DO NOT override if user already set another activity
        if (existing == null) {
          final newEntry = TimelineEntry(
            id: id,
            userId: userId,
            date: selectedDate,
            startTime: start,
            endTime: start.add(const Duration(hours: 1)),
            activity: 'Sleep',
            notes: '',
          );
          await entriesColl.doc(id).set(newEntry.toMap(), SetOptions(merge: true));
        } else if (existing.activity.isEmpty) {
          // only auto-fill if user hasn't picked something yet
          await entriesColl.doc(existing.id).update({'activity': 'Sleep'});
        }
      } else {
        // should NOT be sleep
        if (existing != null && existing.activity == 'Sleep') {
          await entriesColl.doc(existing.id).update({'activity': ''});
        }
      }
    }
  }

  Future<void> _loadUserSettings() async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      final settingsRef = getFirestore()
          .collection('user_settings')
          .doc(user.uid);

      final settings = await settingsRef.get();
      if (settings.exists) {
        final data = settings.data()!;
        final sleepTxt = data['sleepTime'] ?? '23:00';
        final wakeTxt = data['wakeTime'] ?? '7:00';

        setState(() {
          _sleepTimeController.text = sleepTxt;
          _wakeTimeController.text = wakeTxt;
          sleepTime = _parseTime(sleepTxt);
          wakeTime = _parseTime(wakeTxt);
          final List<String> customActs = List<String>.from(data['customActivities'] ?? []);
          _recentActivities = List<String>.from(data['recentActivities'] ?? []);
          // Always include the built-in defaults, then any user custom ones
          _activities = [
            ...kDefaultActivities,
            ...customActs,
          ];
          _archivedActivities = List<String>.from(data['archivedActivities'] ?? []);
          _subActivities = (data['subActivities'] as Map<String, dynamic>? ?? {})
              .map((k, v) => MapEntry(k, List<String>.from(v as List)));
          _dedupCats();
          // ensure 'Sleep' is always present
          if (!_activities.contains('Sleep')) {
            _activities.insert(0,'Sleep');
          }
        });

        WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
        await _reconcileSleepEntriesForSelectedDate();
      } else {
        // Initialize with default settings if none exist
        await settingsRef.set({
          'sleepTime': '23:00',
          'wakeTime': '7:00',
          // Start with no custom activities; built-in defaults are always present client-side
          'customActivities': [],
          'archivedActivities': [],
          'recentActivities': [],
          'lastUpdated': FieldValue.serverTimestamp(),
        });
        setState(() {
          _sleepTimeController.text = '23:00';
          _wakeTimeController.text = '7:00';
          _activities = List.from(kDefaultActivities);
          _archivedActivities = [];
          _recentActivities = [];
          _dedupCats();
        });
        WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
        await _reconcileSleepEntriesForSelectedDate();
      }
    } catch (e) {
      final messenger = ScaffoldMessenger.maybeOf(context);
      messenger?.showSnackBar(
        const SnackBar(content: Text('Unable to load settings. Please try again later.')),
      );
    }
  }

  Future<void> _scrollToNow() async {
    final now = DateTime.now();
    final int hour = now.hour;
    // If it's effectively 30 min block (>= 30) AND that hour is split, scroll to :30
    // But if hour not split, :30 doesn't exist, so scroll to :00
    final bool target30 = _splitHours.contains(hour) && now.minute >= 30;
    final id = _noteKey(hour, target30 ? 30 : 0);

    final key = _blockKeys[id];
    if (key?.currentContext != null) {
      Scrollable.ensureVisible(
        key!.currentContext!,
        duration: const Duration(milliseconds: 500),
        curve: Curves.easeInOut,
        alignment: 0.1, // slightly below top
      );
    }
  }

  void _scrollToWakeTime() {
    if (wakeTime == null) return;
    // same logic, assume wake time is usually on the hour, but if we stored minutes implies precision
    // For simplicity, simplest approximation
    final id = _noteKey(wakeTime!.hour, 0);
    final key = _blockKeys[id];
    if (key?.currentContext != null) {
       Scrollable.ensureVisible(
        key!.currentContext!,
        alignment: 0.1,
      );
    } else {
      // if not mounted yet? Should unlikely be the case with SingleChildScrollView 
      // unless frame hasn't built.
       WidgetsBinding.instance.addPostFrameCallback((_) {
         if (key?.currentContext != null) {
            Scrollable.ensureVisible(
              key!.currentContext!,
              alignment: 0.1,
            );
         }
       });
    }
  }

  bool _isSleepHour(int hour) {
    if (sleepTime == null || wakeTime == null) return false;
    final sleepHour = sleepTime!.hour;
    final wakeHour = wakeTime!.hour;
    if (sleepHour < wakeHour) {
      return hour >= sleepHour && hour < wakeHour;
    } else {
      // Sleep crosses midnight
      return hour >= sleepHour || hour < wakeHour;
    }
  }

  String _docId(DateTime dt) => DateFormat('yyyyMMdd_HHmm').format(dt);

  Future<void> _ensureSleepEntry(int hour, List<TimelineEntry> existingEntries) async {
    final alreadyExists = existingEntries.any((e) => e.startTime.hour == hour);
    if (alreadyExists) return;
    final userId = FirebaseAuth.instance.currentUser?.uid;
    if (userId == null) return;
    final start = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour);
    final newEntry = TimelineEntry(
      id: _docId(start),
      userId: userId,
      date: selectedDate,
      startTime: start,
      endTime: start.add(const Duration(hours: 1)),
      activity: 'Sleep',
      notes: '',
    );
    final entriesColl = getFirestore()
        .collection('timeline_entries')
        .doc(userId)
        .collection('entries');
    await entriesColl.doc(newEntry.id).set(newEntry.toMap(), SetOptions(merge: true));
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Timeline'),
        actions: [
          ValueListenableBuilder<bool>(
            valueListenable: _showRetroNotifier,
            builder: (context, showRetro, _) => IconButton(
              icon: Icon(showRetro ? Icons.visibility : Icons.visibility_off),
              tooltip: showRetro ? 'Hide Retro' : 'Show Retro',
              onPressed: () => _showRetroNotifier.value = !showRetro,
            ),
          ),
          IconButton(
            icon: const Icon(Icons.bar_chart),
            tooltip: 'Analytics',
            onPressed: () => Navigator.pushNamed(context, '/analytics'),
          ),
          IconButton(
            icon: const Icon(Icons.access_time),
            tooltip: 'Jump to Now',
            onPressed: _scrollToNow,
          ),
          PopupMenuButton<String>(
            tooltip: 'Customize',
            onSelected: (value) async {
              switch (value) {
                case 'sleep':
                  _showSleepDialog(context);
                  break;
                case 'Activities':
                  _showActivitiesDialog(context);
                  break;
                case 'habits':
                  Navigator.pushNamed(context, '/habits');
                  break;
                case 'template':
                  await Navigator.pushNamed(context, '/template');
                  if (mounted) setState(() {});
                  break;
                case 'signout':
                  await FirebaseAuth.instance.signOut();
                  // On non-web, also sign out Google account to avoid auto re-auth
                  try{ await GoogleSignIn().signOut(); } catch(_){}
                  if (mounted) {
                    Navigator.of(context).pushAndRemoveUntil(
                      MaterialPageRoute(builder: (_) => const LoginScreen()),
                      (route) => false,
                    );
                  }
                  break;
              }
            },
            itemBuilder: (context) => [
              PopupMenuItem(
                value: 'sleep',
                child: ListTile(
                  leading: const Icon(Icons.bedtime),
                  title: const Text('Sleep timings'),
                ),
              ),
              PopupMenuItem(
                value: 'Activities',
                child: ListTile(
                  leading: const Icon(Icons.label),
                  title: const Text('Activities'),
                ),
              ),
              PopupMenuItem(
                value: 'habits',
                child: ListTile(
                  leading: const Icon(Icons.check_circle_outline),
                  title: const Text('Habits'),
                ),
              ),
              PopupMenuItem(
                value: 'template',
                child: ListTile(
                  leading: const Icon(Icons.content_copy),
                  title: const Text('Template'),
                ),
              ),
              PopupMenuItem(
                value: 'signout',
                child: ListTile(
                  leading: const Icon(Icons.logout),
                  title: const Text('Sign out'),
                ),
              ),
            ],
          ),
        ],
      ),
      body: Column(
        children: [
          CalendarStrip(
            selectedDate: selectedDate,
            onDateSelected: (date) {
              // Save current offset is already handled by listener.
              setState(() {
                // clear controllers when switching date to avoid residue
                // Note: managed by TimelineHourTile now
                _blockKeys.clear();
                
                selectedDate = date;
                _currentDateKey = DateFormat('yyyy-MM-dd').format(selectedDate);
                _initStream();
                _loadDayComplete();
              });

              // After frame, jump to stored offset or fallback to wake time
              final key = DateFormat('yyyy-MM-dd').format(selectedDate);
              final double? saved = _offsetCache[key];
              if (saved != null) {
                _pendingScrollOffset = saved;
              } else {
                // fallback after list builds
                _pendingScrollOffset = null;
                WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
              }
            },
            completedDates: _loggedDates,
          ),
          ValueListenableBuilder<bool>(
            valueListenable: _dayCompleteNotifier,
            builder: (context, done, _) => CheckboxListTile(
              key: ValueKey(done),
              title: const Text('Day fully logged'),
              value: done,
              onChanged: (val) {
                if (val != null) _setDayComplete(val);
              },
            ),
          ),
          ValueListenableBuilder<bool>(
            valueListenable: _habitsExpandedNotifier,
            builder: (context, expanded, _) => ExpansionTile(
              title: const Text('Habits'),
              initiallyExpanded: expanded,
              maintainState: true,
              onExpansionChanged: (val) => _habitsExpandedNotifier.value = val,
              children: [
                HabitTracker(date: selectedDate),
              ],
            ),
          ),
          Expanded(
            child: _buildTimelineBody(),
          ),
        ],
      ),
    );
  }

  Widget _buildTimelineBody() {
    return StreamBuilder<QuerySnapshot>(
      key: ValueKey(_currentDateKey),
      stream: _currentStream,
      builder: _buildTimelineStream,
    );
  }

  Widget _buildTimelineStream(BuildContext context, AsyncSnapshot<QuerySnapshot> snapshot) {
    if (snapshot.hasError) {
      return Center(child: Text('Error: ${snapshot.error}'));
    }
    if (!snapshot.hasData) {
      return const Center(child: CircularProgressIndicator());
    }
    var entries = snapshot.data?.docs
            .map((doc) => TimelineEntry.fromFirestore(doc))
            .toList() ?? [];

    // If this snapshot only represents writes that originated from
    // this device (i.e. they are still pending confirmation from
    // the server) then re-use the previously rendered list instead
    // of forcing a full rebuild. This significantly reduces the
    // visible flicker that occurred while typing or selecting
    // Activities because every local write triggered a rebuild of
    // the entire timeline.
    final bool onlyLocalUpdates = (snapshot.data != null &&
        snapshot.data!.docChanges.isNotEmpty &&
        snapshot.data!.docChanges.every((c) => c.doc.metadata.hasPendingWrites));

    if (onlyLocalUpdates) {
      // Apply the pending local changes to the cached list so the
      // UI still reflects the user's edits instantly.
      for (final change in snapshot.data!.docChanges) {
        final updated = TimelineEntry.fromFirestore(change.doc);
        final idx = _cachedEntries.indexWhere((e) => e.id == updated.id);
        switch (change.type) {
          case DocumentChangeType.removed:
            if (idx != -1) _cachedEntries.removeAt(idx);
            break;
          case DocumentChangeType.modified:
          case DocumentChangeType.added:
            if (idx == -1) {
              _cachedEntries.add(updated);
            } else {
              _cachedEntries[idx] = updated;
            }
            break;
        }
      }
      entries = _cachedEntries;
    } else {
      _cachedEntries = entries;
    }

    // update splitHours set based on presence of :30 entries
    _splitHours = entries
        .where((e) => e.startTime.minute == 30)
        .map((e) => e.startTime.hour)
        .toSet();

    // Always attempt to apply template (idempotent)
    _applyTemplateIfNeeded(entries);

    // Autofill sleep blocks only for today or future; leave past dates untouched
    final DateTime today = DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day);
    final bool isPastDate = selectedDate.isBefore(today);
    if (!isPastDate && sleepTime != null && wakeTime != null) {
      for (var hour = 0; hour < 24; hour++) {
        if (_isSleepHour(hour)) {
          _ensureSleepEntry(hour, entries);
        }
      }
    }

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_pendingScrollOffset!=null && _scrollController.hasClients) {
        final max=_scrollController.position.maxScrollExtent;
        _scrollController.jumpTo(_pendingScrollOffset!.clamp(0,max));
        _pendingScrollOffset=null;
      }
    });

    return SingleChildScrollView(
      controller: _scrollController,
      child: ValueListenableBuilder<bool>(
        valueListenable: _showRetroNotifier,
        builder: (context, showRetro, _) {
          return Column(
            children: List.generate(24, (hour) {
              // Retrieve any existing entries for this hour and minute markers
              String? _sectionTitle(int h){
                if(h==6) return 'Morning';
                if(h==12) return 'Afternoon';
                if(h==18) return 'Evening';
                return null;
              }

              TimelineEntry _blank(int minute) {
                final start=DateTime(selectedDate.year,selectedDate.month,selectedDate.day,hour,minute);
                return TimelineEntry(
                  id: _docId(start),
                  userId: FirebaseAuth.instance.currentUser?.uid ?? '',
                  date: selectedDate,
                  startTime: DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, minute),
                  endTime: DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, minute).add(Duration(minutes: minute==0?60:30)),
                  activity: '',
                  notes: '',
                );
              }

              final entry00 = entries.firstWhere(
                (e) => e.startTime.hour == hour && e.startTime.minute == 0,
                orElse: () => _blank(0),
              );

              final entry30 = _splitHours.contains(hour)
                  ? entries.firstWhere(
                      (e) => e.startTime.hour == hour && e.startTime.minute == 30,
                      orElse: () => _blank(30),
                    )
                  : null;
              
              final key00 = _blockKeys.putIfAbsent(_noteKey(hour, 0), () => GlobalKey());
              final key30 = _splitHours.contains(hour) 
                  ? _blockKeys.putIfAbsent(_noteKey(hour, 30), () => GlobalKey())
                  : null;

              final tile = TimelineHourTile(
                key: ValueKey(hour),
                hour: hour,
                entry00: entry00,
                entry30: entry30,
                isSplit: _splitHours.contains(hour),
                showRetro: showRetro,
                onToggleSplit: () => _toggleSplit(hour),
                onUpdateEntry: _updateEntry,
                availableActivities: _flattenCats(),
                recentActivities: _recentActivities,
                onPromptCustomActivity: () => _promptCustomActivity(context),
                onUpdateRecentActivity: (act) {
                  if (!_recentActivities.contains(act)) {
                    setState(() {
                      _recentActivities.insert(0, act);
                      if (_recentActivities.length > 5) _recentActivities.removeLast();
                    });
                    _saveSettings();
                  }
                },
                key00: key00,
                key30: key30,
              );

              final List<Widget> cardChildren=[];
              final section=_sectionTitle(hour);
              if(section!=null){
                cardChildren.add(Padding(
                  padding: const EdgeInsets.symmetric(horizontal:16,vertical:8),
                  child: Text(section,style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
                ));
              }
              cardChildren.add(tile);
              return Column(children: cardChildren);
            }),
          );
        }
      ),
    );
  }

  Future<String?> _promptCustomActivity(BuildContext context) async {
    String? custom;
    await showDialog(
      context: context,
      builder: (ctx) {
        final c = TextEditingController();
        return AlertDialog(
          title: const Text('New Activity'),
          content: TextField(
            controller: c,
            autofocus: true,
            decoration: const InputDecoration(hintText: 'Activity Name'),
          ),
          actions: [
            TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),
            TextButton(
              onPressed: () {
                custom = c.text.trim();
                Navigator.pop(ctx);
              },
              child: const Text('Add'),
            ),
          ],
        );
      },
    );
    return custom;
  }

  Future<void> _updateEntry(TimelineEntry entry, String activity, String notes, {bool isPlan=false}) async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      final entriesColl = getFirestore()
          .collection('timeline_entries')
          .doc(user.uid)
          .collection('entries');

      final docId = _docId(entry.startTime);

      final fullEntry = TimelineEntry(
        id: docId,
        userId: user.uid,
        date: entry.date,
        startTime: entry.startTime,
        endTime: entry.endTime,
        planactivity: isPlan ? activity : entry.planactivity,
        planNotes: isPlan ? notes : entry.planNotes,
        activity: isPlan ? entry.activity : activity,
        notes: isPlan ? entry.notes : notes,
      );

      await entriesColl.doc(docId).set(fullEntry.toMap());
    } catch (e) {
      final messenger = ScaffoldMessenger.maybeOf(context);
      messenger?.showSnackBar(
        const SnackBar(content: Text('Unable to update entry. Please try again later.')),
      );
    }
  }

  Future<void> _showSleepDialog(BuildContext context) async {
    TimeOfDay? dialogSleep = sleepTime ?? (_sleepTimeController.text.isNotEmpty ? _parseTime(_sleepTimeController.text) : const TimeOfDay(hour: 23, minute: 0));
    TimeOfDay? dialogWake = wakeTime ?? (_wakeTimeController.text.isNotEmpty ? _parseTime(_wakeTimeController.text) : const TimeOfDay(hour: 7, minute: 0));

    final result = await showDialog(
      context: context,
      barrierDismissible: true,
      builder: (ctx) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return AlertDialog(
              title: const Text('Sleep Timings'),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      const Text('Sleep Time'),
                      TextButton(
                        onPressed: () async {
                          final t = await showTimePicker(
                            context: context,
                            initialTime: dialogSleep ?? const TimeOfDay(hour: 23, minute: 0),
                          );
                          if (t != null) {
                            setDialogState(() => dialogSleep = t);
                            _sleepTimeController.text = _fmt24(t);
                            await _saveSettings(refreshTimeline: true);
                          }
                        },
                        child: Text(dialogSleep?.format(context) ?? 'Set'),
                      ),
                    ],
                  ),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      const Text('Wake Time'),
                      TextButton(
                        onPressed: () async {
                          final t = await showTimePicker(
                            context: context,
                            initialTime: dialogWake ?? const TimeOfDay(hour: 7, minute: 0),
                          );
                          if (t != null) {
                            setDialogState(() => dialogWake = t);
                            _wakeTimeController.text = _fmt24(t);
                            await _saveSettings(refreshTimeline: true);
                          }
                        },
                        child: Text(dialogWake?.format(context) ?? 'Set'),
                      ),
                    ],
                  ),
                ],
              ),
              actions: [
                TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Close')),
              ],
            );
          },
        );
      },
    );

    // Rebuild timeline to reflect any activity changes made inside the dialog
    if (mounted && result != null) {
      setState(() {});
    }
  }

  Future<void> _showActivitiesDialog(BuildContext context) async {
    final TextEditingController addCatController = TextEditingController();

    await showDialog(
      context: context,
      barrierDismissible: true,
      builder: (ctx) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return Dialog(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: SingleChildScrollView(
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      const Text('Activities', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
                      const SizedBox(height: 16),
                      Row(
                        children: [
                          Expanded(
                            child: TextField(
                              controller: addCatController,
                              decoration: const InputDecoration(labelText: 'Add activity'),
                            ),
                          ),
                          IconButton(
                            icon: const Icon(Icons.add),
                            onPressed: () async {
                              final newCat = addCatController.text.trim();
                              if (newCat.isEmpty) return;
                              setDialogState(() {
                                _activities.add(newCat);
                                _archivedActivities.remove(newCat); // ensure it's active
                                _dedupCats();
                              });
                              addCatController.clear();
                              await _saveSettings(refreshTimeline: true);
                            },
                          ),
                        ],
                      ),
                      const SizedBox(height: 8),
                      Container(
                        constraints: const BoxConstraints(maxHeight: 300),
                        child: ListView.builder(
                          shrinkWrap: true,
                          itemCount: _activities.length,
                          itemBuilder: (context, index) {
                            final parent = _activities[index];
                            final subs = _subActivities[parent] ?? [];
                            final isDefault = _protectedActivities.contains(parent);
                            final TextEditingController subCtrl = TextEditingController();
                            return ExpansionTile(
                              title: Text(_displayLabel(parent)),
                              trailing: isDefault
                                  ? null
                                  : IconButton(
                                      icon: const Icon(Icons.delete),
                                      onPressed: () async {
                                        setDialogState(() {
                                          _activities.remove(parent);
                                          if (!_archivedActivities.contains(parent)) {
                                            _archivedActivities.add(parent);
                                          }
                                          // keep subActivities map intact so past subs remain
                                          _dedupCats();
                                        });
                                        await _saveSettings(refreshTimeline: true);
                                      },
                                    ),
                              children: [
                                ...subs.map((s) => Padding(
                                      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 4),
                                      child: Row(
                                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                        children: [
                                          Text(s),
                                          IconButton(
                                            icon: const Icon(Icons.delete_outline),
                                            onPressed: () async {
                                              await _removeSubactivity(parent, s);
                                              setDialogState(() {});
                                            },
                                          ),
                                        ],
                                      ),
                                    )),
                                Padding(
                                  padding: const EdgeInsets.symmetric(horizontal: 24),
                                  child: Row(
                                    children: [
                                      Expanded(
                                        child: TextField(
                                          controller: subCtrl,
                                          decoration: const InputDecoration(labelText: 'Add sub-activity'),
                                        ),
                                      ),
                                      IconButton(
                                        icon: const Icon(Icons.add_circle_outline),
                                        onPressed: () async {
                                          final sub = subCtrl.text.trim();
                                          if (sub.isEmpty) return;
                                          await _addSubactivity(parent, sub);
                                          subCtrl.clear();
                                          setDialogState(() {});
                                        },
                                      ),
                                    ],
                                  ),
                                ),
                              ],
                            );
                          },
                        ),
                      ),
                      const SizedBox(height: 8),
                      TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Close')),
                    ],
                  ),
                ),
              ),
            );
          },
        );
      },
    );
  }

  Future<void> _saveSettings({bool refreshTimeline = true}) async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      final settingsRef = getFirestore()
          .collection('user_settings')
          .doc(user.uid);

      _dedupCats();

      // Determine if times actually changed (compare by hour/minute not string)
      TimeOfDay _toTod(String s) => _parseTime(s);

      final prevSleep = sleepTime ?? _toTod(_sleepTimeController.text);
      final prevWake = wakeTime ?? _toTod(_wakeTimeController.text);
      final newSleep = _toTod(_sleepTimeController.text);
      final newWake = _toTod(_wakeTimeController.text);
      final bool timesChanged = prevSleep != newSleep || prevWake != newWake;

      // Persist only activities that are not part of the built-in defaults
      final Set<String> defaultSet = Set.of(kDefaultActivities);
      final List<String> customOnly = _activities.where((a) => !defaultSet.contains(a)).toList();

      await settingsRef.set({
        'sleepTime': _sleepTimeController.text,
        'wakeTime': _wakeTimeController.text,
        'customActivities': customOnly,
        'archivedActivities': _archivedActivities,
        'subActivities': _subActivities,
        'recentActivities': _recentActivities,
        'lastUpdated': FieldValue.serverTimestamp(),
      }, SetOptions(merge: true));

      // refresh local vars
      if (refreshTimeline && mounted) {
        setState(() {
          if (timesChanged) {
            sleepTime = newSleep;
            wakeTime = newWake;
          }
          // ensure Activities list refreshes in timeline & dropdown
          _activities = List<String>.from(_activities);
        });

        if (timesChanged) {
          // after rebuild, scroll
          WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
        }
      }

      if (timesChanged) {
        await _reconcileSleepEntriesForSelectedDate();
      }

      ScaffoldMessenger.maybeOf(context)?.showSnackBar(
        const SnackBar(content: Text('Settings saved')),
      );
    } catch (e) {
      ScaffoldMessenger.maybeOf(context)?.showSnackBar(
        const SnackBar(content: Text('Unable to save settings. Please try again later.')),
      );
    }
  }

  String _fmt24(TimeOfDay t) => '${t.hour.toString().padLeft(2, '0')}:${t.minute.toString().padLeft(2, '0')}';

  void _initStream() {
    _currentStream = getFirestore()
          .collection('timeline_entries')
          .doc(FirebaseAuth.instance.currentUser?.uid ?? '')
          .collection('entries')
          .where('date', isEqualTo: DateFormat('yyyy-MM-dd').format(selectedDate))
          .snapshots();
  }

  void _dedupCats() {
    _activities = _activities.toSet().toList();
    _archivedActivities = _archivedActivities.toSet().toList();
  }

  Future<void> _toggleSplit(int hour) async {
    final userId = FirebaseAuth.instance.currentUser?.uid;
    if (userId == null) return;
    // No need to capture offset; we will not rebuild the whole list.
    final entriesColl = getFirestore()
        .collection('timeline_entries')
        .doc(userId)
        .collection('entries');

    final halfStart = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, 30);
    final halfDocId = _docId(halfStart);

    if (_splitHours.contains(hour)) {
      // MERGE -> remove 30-minute entry
      await entriesColl.doc(halfDocId).delete();

      _splitHours.remove(hour);
      _cachedEntries.removeWhere((e) => e.id == halfDocId);


    } else {
      // SPLIT -> add blank 30-minute entry
      final newEntry = TimelineEntry(
        id: halfDocId,
        userId: userId,
        date: selectedDate,
        startTime: halfStart,
        endTime: halfStart.add(const Duration(minutes: 30)),
        activity: '',
        notes: '',
      );
      await entriesColl.doc(halfDocId).set(newEntry.toMap());

      _splitHours.add(hour);
      _cachedEntries.add(newEntry);
    }

    // Rebuild only if the widget is still in the tree; this redraws the two
    // affected rows without resetting scroll position.
    
    // We rely on the StreamBuilder to rebuild the UI when the data changes.
    // However, we still want to ensure visibility after that update propagates.
    // This is tricky because we don't know exactly when the frame will render.
    // But usually local latency compensation is fast.
    
    // Workaround: We wait for the stream to likely have updated? 
    // No, better to genericize the ensureVisible.
    
    // For now, let's just remove setState. The StreamBuilder will handle the rebuild.
    // We can try to attach the scroll correction to the next frame, risking it runs before the stream update.
    // But if the stream update is synchronous (cached), it works.

  }

  String _noteKey(int hour, int minute) => '${hour.toString().padLeft(2,'0')}:${minute.toString().padLeft(2,'0')}';

  String _dateStr(DateTime d)=>DateFormat('yyyy-MM-dd').format(d);

  Future<void> _loadDayComplete() async{
    final uid=FirebaseAuth.instance.currentUser?.uid; if(uid==null) return;
    final doc=await getFirestore().collection('daily_logs').doc(uid).collection('logs').doc(_dateStr(selectedDate)).get();
    _dayCompleteNotifier.value = doc.exists && (doc.data()?['complete']==true);
  }

  Future<void> _setDayComplete(bool val) async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;

    // Optimistically update UI immediately
    _dayCompleteNotifier.value = val;

    final ref = getFirestore()
        .collection('daily_logs')
        .doc(uid)
        .collection('logs')
        .doc(_dateStr(selectedDate));

    try {
      if (val) {
        await ref.set({
          'date': _dateStr(selectedDate),
          'complete': true,
          'lastUpdated': FieldValue.serverTimestamp(),
        });
        _loggedDates.add(_dateStr(selectedDate));
      } else {
        await ref.delete();
        _loggedDates.remove(_dateStr(selectedDate));
      }
    } catch (e) {
      // Revert on failure and inform user
      _dayCompleteNotifier.value = !val;
      ScaffoldMessenger.maybeOf(context)?.showSnackBar(
        const SnackBar(content: Text('Could not update day status. Please try again.')),
      );
    }
  }

  // ---------- Sub-activity helpers ----------
  Future<void> _addSubactivity(String parent, String sub) async {
    if (sub.trim().isEmpty) return;
    if (!_activities.contains(parent)) {
      _activities.add(parent);
    }
    final list = _subActivities[parent] ?? <String>[];
    if (!list.contains(sub)) {
      list.add(sub);
      _subActivities[parent] = list;
      await _saveSettings(refreshTimeline: true);

      final double offset=_scrollController.hasClients?_scrollController.offset:0;
      if (mounted) setState(() {});
      WidgetsBinding.instance.addPostFrameCallback((_){
        if(_scrollController.hasClients){
          _scrollController.jumpTo(offset.clamp(0,_scrollController.position.maxScrollExtent));
        }
      });
    }
  }

  Future<void> _removeSubactivity(String parent, String sub) async {
    final list = _subActivities[parent];
    if (list == null) return;
    list.remove(sub);
    if (list.isEmpty) {
      _subActivities.remove(parent);
    } else {
      _subActivities[parent] = list;
    }
    await _saveSettings(refreshTimeline: true);
    final double offset=_scrollController.hasClients?_scrollController.offset:0;
    if (mounted) setState(() {});
    WidgetsBinding.instance.addPostFrameCallback((_){
      if(_scrollController.hasClients){
        _scrollController.jumpTo(offset.clamp(0,_scrollController.position.maxScrollExtent));
      }
    });
  }

  Future<void> _applyTemplateIfNeeded(List<TimelineEntry> currentEntries) async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;
    final dateStr = _dateStr(selectedDate);
    // Only today or future
    final DateTime today = DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day);
    if (selectedDate.isBefore(today)) return;
    if (_dayComplete) return; // don't overwrite completed day

    // fetch template docs
    final snap = await getFirestore()
        .collection('template_entries')
        .doc(uid)
        .collection('entries')
        .get();
    if (snap.docs.isEmpty) {
      return; // no template yet
    }

    final Map<String, TimelineEntry> existingMap = {
      for (var e in currentEntries) _noteKey(e.startTime.hour, e.startTime.minute): e
    };

    final batch = getFirestore().batch();
    final entriesColl = getFirestore().collection('timeline_entries').doc(uid).collection('entries');

    for (final doc in snap.docs) {
      final hour = int.parse(doc.id.substring(0, 2));
      final minute = int.parse(doc.id.substring(2));
      final key = _noteKey(hour, minute);
      final tmplPlanCat = doc['planactivity'] ?? doc['activity'] ?? '';
      final tmplPlanNotes = doc['planNotes'] ?? doc['notes'] ?? '';
      final tmplRetroCat = (doc['activity'] ?? '') == 'Sleep' ? 'Sleep' : '';
      final tmplRetroNotes = tmplRetroCat.isNotEmpty ? (doc['notes'] ?? '') : '';

      if (existingMap.containsKey(key)) {
        final existing = existingMap[key]!;
        final Map<String,dynamic> upd={};
        if(existing.planactivity.isEmpty){
          upd['planactivity']=tmplPlanCat; upd['planNotes']=tmplPlanNotes; }
        if(tmplRetroCat.isNotEmpty && existing.activity.isEmpty){
          upd['activity']=tmplRetroCat; upd['notes']=tmplRetroNotes; }
        if(upd.isNotEmpty){batch.update(entriesColl.doc(existing.id),upd);}        
        continue;
      }

      final start = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, minute);
      final newEntry = TimelineEntry(
        id: _docId(start),
        userId: uid,
        date: selectedDate,
        startTime: start,
        endTime: start.add(Duration(minutes: minute == 0 ? 60 : 30)),
        planactivity: tmplPlanCat,
        planNotes: tmplPlanNotes,
        activity: tmplRetroCat,
        notes: tmplRetroNotes,
      );
      batch.set(entriesColl.doc(newEntry.id), newEntry.toMap());
    }
    await batch.commit();
  }

  List<String> _flattenCats() {
    final flatSet = <String>{};
    void addParent(String parent) {
      flatSet.add(parent);
      final subs = _subActivities[parent] ?? [];
      for (final s in subs) {
        flatSet.add('$parent / $s');
      }
    }

    for (final parent in _activities) {
      addParent(parent);
    }

    final DateTime today = DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day);
    if (selectedDate.isBefore(today)) {
      for (final parent in _archivedActivities) {
        addParent(parent);
      }
    }

    return flatSet.toList();
  }

  Future<String?> _promptCustomactivity() async {
    final TextEditingController ctrl = TextEditingController();
    return showDialog<String>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Custom activity'),
        content: TextField(
          controller: ctrl,
          autofocus: true,
          decoration: const InputDecoration(hintText: 'Enter activity'),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),
          TextButton(onPressed: () => Navigator.pop(ctx, ctrl.text.trim()), child: const Text('OK')),
        ],
      ),
    );
  }

  void _updateRecent(String act) {
    _recentActivities.remove(act);
    _recentActivities.insert(0, act);
    if (_recentActivities.length > 8) {
      _recentActivities = _recentActivities.sublist(0, 8);
    }
    final user = FirebaseAuth.instance.currentUser;
    if (user != null) {
      getFirestore()
          .collection('user_settings')
          .doc(user.uid)
          .set({'recentActivities': _recentActivities}, SetOptions(merge: true));
    }
  }

  Future<void> _loadLoggedDates() async {
    final uid=FirebaseAuth.instance.currentUser?.uid; if(uid==null) return;
    final today=DateTime.now();
    final start=today.subtract(const Duration(days:7));
    final end=today.add(const Duration(days:7));
    final snap=await getFirestore().collection('daily_logs').doc(uid).collection('logs')
      .where('date', isGreaterThanOrEqualTo: DateFormat('yyyy-MM-dd').format(start))
      .where('date', isLessThanOrEqualTo: DateFormat('yyyy-MM-dd').format(end))
      .get();
    _loggedDates = snap.docs.map((d)=>d.id).toSet();
    if(mounted) setState((){});
  }
} 