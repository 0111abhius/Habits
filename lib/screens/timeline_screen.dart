import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../models/timeline_entry.dart';
import '../widgets/calendar_strip.dart';
import '../widgets/habit_tracker.dart';
import '../main.dart';  // Import for getFirestore()
import 'package:intl/intl.dart';
import 'dart:async';
import '../utils/activities.dart';
import '../widgets/activity_picker.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'activities_management_screen.dart';
import 'login_screen.dart';
import '../widgets/timeline_hour_tile.dart';
import 'day_planning_assistant.dart';
import '../models/timeline_view_mode.dart';
import '../widgets/timeline_view_header.dart';

class TimelineScreen extends StatefulWidget {
  const TimelineScreen({super.key});

  @override
  State<TimelineScreen> createState() => _TimelineScreenState();
}

class _TimelineScreenState extends State<TimelineScreen> {
  DateTime selectedDate = DateTime.now();
  static const List<String> _protectedActivities = ['Sleep'];
  List<String> _activities = List.from(kDefaultActivities);

  String _displayLabel(String act) => displayActivity(act);

  List<String> _archivedActivities = []; // Activities removed from active but kept for history
  Map<String, List<String>> _subActivities = {}; // parent -> list of subs

  TimeOfDay? wakeTime;
  TimeOfDay? sleepTime;
  late final ScrollController _scrollController;
  final TextEditingController _sleepTimeController = TextEditingController();
  final TextEditingController _wakeTimeController = TextEditingController();

  double? _pendingScrollOffset;

  Set<int> _splitHours = {}; // hours that have a 30-minute split for the selected date
  // Cache of the most recently rendered entries list. This lets us re-use the
  // previous UI when the only Firestore changes are still pending writes
  // generated by this device â€“ preventing a visible full list refresh.
  List<TimelineEntry> _cachedEntries = [];

  final ValueNotifier<bool> _habitsExpandedNotifier = ValueNotifier(true);
  final ValueNotifier<TimelineViewMode> _viewModeNotifier = ValueNotifier(TimelineViewMode.plan);

  bool get _habitsExpanded => _habitsExpandedNotifier.value;
  TimelineViewMode get _viewMode => _viewModeNotifier.value;

  // Using a ValueNotifier means toggling the "Day fully logged" checkbox
  // only rebuilds that specific part of the UI instead of the whole timeline.
  final ValueNotifier<bool> _dayCompleteNotifier = ValueNotifier(false);

  // Convenience getter so existing read-access sites keep working.
  bool get _dayComplete => _dayCompleteNotifier.value;

  final Map<String, GlobalKey> _blockKeys = {};
  static final Map<String, double> _offsetCache = {}; // keyed by yyyy-MM-dd (selected date)
  late String _currentDateKey;

  List<String> _recentActivities = [];

  Set<String> _loggedDates = {};
  late Stream<QuerySnapshot> _currentStream;

  @override
  void initState() {
    super.initState();
    _currentDateKey = DateFormat('yyyy-MM-dd').format(selectedDate);
    _initStream();
    _scrollController = ScrollController(initialScrollOffset: _offsetCache[_currentDateKey] ?? 0)
      ..addListener(() {
        _offsetCache[_currentDateKey] = _scrollController.offset;
      });
    _loadUserSettings();
    _loadDayComplete();
    _loadLoggedDates();
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _sleepTimeController.dispose();
    _wakeTimeController.dispose();


    _pendingScrollOffset=null;
    super.dispose();
  }

  // Helper to parse 'HH:mm' strings to TimeOfDay
  TimeOfDay _parseTime(String s) {
    final parts = s.split(':');
    return TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1]));
  }

  Future<void> _reconcileSleepEntriesForSelectedDate() async {
    if (sleepTime == null || wakeTime == null) return;
    // Do not modify historical data: only reconcile for today or future
    final DateTime today = DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day);
    if (selectedDate.isBefore(today)) return;
    final userId = FirebaseAuth.instance.currentUser?.uid;
    if (userId == null) return;

    final entriesColl = getFirestore()
        .collection('timeline_entries')
        .doc(userId)
        .collection('entries');

    final dateStr = DateFormat('yyyy-MM-dd').format(selectedDate);
    final snapshot = await entriesColl.where('date', isEqualTo: dateStr).get();
    final entries = snapshot.docs.map((d) => TimelineEntry.fromFirestore(d)).toList();

    for (var hour = 0; hour < 24; hour++) {
      final shouldSleep = _isSleepHour(hour);
      final matching = entries.where((e) => e.startTime.hour == hour);
      final TimelineEntry? existing = matching.isNotEmpty ? matching.first : null;

      final start = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour);
      final id = _docId(start);

      if (shouldSleep) {
        // ensure a placeholder exists but DO NOT override if user already set another activity
        if (existing == null) {
          final newEntry = TimelineEntry(
            id: id,
            userId: userId,
            date: selectedDate,
            startTime: start,
            endTime: start.add(const Duration(hours: 1)),
            activity: 'Sleep',
            notes: '',
          );
          await entriesColl.doc(id).set(newEntry.toMap(), SetOptions(merge: true));
        } else if (existing.activity.isEmpty) {
          // only auto-fill if user hasn't picked something yet
          await entriesColl.doc(existing.id).update({'activity': 'Sleep'});
        }
      } else {
        // should NOT be sleep
        if (existing != null && existing.activity == 'Sleep') {
          await entriesColl.doc(existing.id).update({'activity': ''});
        }
      }
    }
  }

  Future<void> _loadUserSettings() async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      final settingsRef = getFirestore()
          .collection('user_settings')
          .doc(user.uid);

      final settings = await settingsRef.get();
      if (settings.exists) {
        final data = settings.data()!;
        final sleepTxt = data['sleepTime'] ?? '23:00';
        final wakeTxt = data['wakeTime'] ?? '7:00';

        setState(() {
          _sleepTimeController.text = sleepTxt;
          _wakeTimeController.text = wakeTxt;
          sleepTime = _parseTime(sleepTxt);
          wakeTime = _parseTime(wakeTxt);
          final List<String> customActs = List<String>.from(data['customActivities'] ?? []);
          _recentActivities = List<String>.from(data['recentActivities'] ?? []);
          // Always include the built-in defaults, then any user custom ones
          _activities = [
            ...kDefaultActivities,
            ...customActs,
          ];
          _archivedActivities = List<String>.from(data['archivedActivities'] ?? []);
          _subActivities = (data['subActivities'] as Map<String, dynamic>? ?? {})
              .map((k, v) => MapEntry(k, List<String>.from(v as List)));
          _dedupCats();
          // ensure 'Sleep' is always present
          if (!_activities.contains('Sleep')) {
            _activities.insert(0,'Sleep');
          }
        });

        WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
        await _reconcileSleepEntriesForSelectedDate();
      } else {
        // Initialize with default settings if none exist
        await settingsRef.set({
          'sleepTime': '23:00',
          'wakeTime': '7:00',
          // Start with no custom activities; built-in defaults are always present client-side
          'customActivities': [],
          'archivedActivities': [],
          'recentActivities': [],
          'lastUpdated': FieldValue.serverTimestamp(),
        });
        setState(() {
          _sleepTimeController.text = '23:00';
          _wakeTimeController.text = '7:00';
          _activities = List.from(kDefaultActivities);
          _archivedActivities = [];
          _recentActivities = [];
          _dedupCats();
        });
        WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
        await _reconcileSleepEntriesForSelectedDate();
      }
    } catch (e) {
      if (!mounted) return;
      final messenger = ScaffoldMessenger.maybeOf(context);
      messenger?.showSnackBar(
        const SnackBar(content: Text('Unable to load settings. Please try again later.')),
      );
    }
  }

  Future<void> _scrollToNow() async {
    final now = DateTime.now();
    final int hour = now.hour;
    // If it's effectively 30 min block (>= 30) AND that hour is split, scroll to :30
    // But if hour not split, :30 doesn't exist, so scroll to :00
    final bool target30 = _splitHours.contains(hour) && now.minute >= 30;
    final id = _noteKey(hour, target30 ? 30 : 0);

    final key = _blockKeys[id];
    if (key?.currentContext != null) {
      Scrollable.ensureVisible(
        key!.currentContext!,
        duration: const Duration(milliseconds: 500),
        curve: Curves.easeInOut,
        alignment: 0.1, // slightly below top
      );
    }
  }

  void _scrollToWakeTime() {
    if (wakeTime == null) return;
    // same logic, assume wake time is usually on the hour, but if we stored minutes implies precision
    // For simplicity, simplest approximation
    final id = _noteKey(wakeTime!.hour, 0);
    final key = _blockKeys[id];
    if (key?.currentContext != null) {
       Scrollable.ensureVisible(
        key!.currentContext!,
        alignment: 0.1,
      );
    } else {
      // if not mounted yet? Should unlikely be the case with SingleChildScrollView 
      // unless frame hasn't built.
       WidgetsBinding.instance.addPostFrameCallback((_) {
         if (key?.currentContext != null) {
            Scrollable.ensureVisible(
              key!.currentContext!,
              alignment: 0.1,
            );
         }
       });
    }
  }

  bool _isSleepHour(int hour) {
    if (sleepTime == null || wakeTime == null) return false;
    final sleepHour = sleepTime!.hour;
    final wakeHour = wakeTime!.hour;
    if (sleepHour < wakeHour) {
      return hour >= sleepHour && hour < wakeHour;
    } else {
      // Sleep crosses midnight
      return hour >= sleepHour || hour < wakeHour;
    }
  }

  String _docId(DateTime dt) => DateFormat('yyyyMMdd_HHmm').format(dt);

  Future<void> _ensureSleepEntry(int hour, List<TimelineEntry> existingEntries) async {
    final alreadyExists = existingEntries.any((e) => e.startTime.hour == hour);
    if (alreadyExists) return;
    final userId = FirebaseAuth.instance.currentUser?.uid;
    if (userId == null) return;
    final start = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour);
    final newEntry = TimelineEntry(
      id: _docId(start),
      userId: userId,
      date: selectedDate,
      startTime: start,
      endTime: start.add(const Duration(hours: 1)),
      activity: 'Sleep',
      notes: '',
    );
    final entriesColl = getFirestore()
        .collection('timeline_entries')
        .doc(userId)
        .collection('entries');
    await entriesColl.doc(newEntry.id).set(newEntry.toMap(), SetOptions(merge: true));
  }

  String _getDateTitle(DateTime date) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final input = DateTime(date.year, date.month, date.day);

    if (input == today) return 'Today';
    
    final yesterday = today.subtract(const Duration(days: 1));
    if (input == yesterday) return 'Yesterday';
    
    final tomorrow = today.add(const Duration(days: 1));
    if (input == tomorrow) return 'Tomorrow';
    
    return DateFormat('EEE, MMM d').format(date);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: GestureDetector(
        onHorizontalDragEnd: (details) {
          if (details.primaryVelocity == null) return;
          const double sensitivity = 300.0;
          
          if (details.primaryVelocity! < -sensitivity) {
            // Swipe Left -> Next Day
            final nextDay = selectedDate.add(const Duration(days: 1));
            setState(() {
              _blockKeys.clear();
              selectedDate = nextDay;
              _currentDateKey = DateFormat('yyyy-MM-dd').format(selectedDate);
              _initStream();
              _loadDayComplete();
            });
            // Reset scroll/cache
            _pendingScrollOffset = null;
            WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
          } else if (details.primaryVelocity! > sensitivity) {
            // Swipe Right -> Previous Day
             final prevDay = selectedDate.subtract(const Duration(days: 1));
             setState(() {
              _blockKeys.clear();
              selectedDate = prevDay;
              _currentDateKey = DateFormat('yyyy-MM-dd').format(selectedDate);
              _initStream();
              _loadDayComplete();
            });
            // Reset scroll/cache
            _pendingScrollOffset = null;
            WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
          }
        },
        child: CustomScrollView(
        controller: _scrollController,
        slivers: [
          SliverAppBar(
            pinned: true,
            title: Text(_getDateTitle(selectedDate), style: const TextStyle(fontWeight: FontWeight.bold)),
            actions: [
              ValueListenableBuilder<bool>(
                valueListenable: _dayCompleteNotifier,
                builder: (context, done, _) => IconButton(
                  icon: Icon(
                    done ? Icons.check_circle : Icons.check_circle_outline,
                    color: done ? Colors.green : null,
                  ),
                  tooltip: done ? 'Day Logged' : 'Mark Day as Logged',
                  onPressed: () => _setDayComplete(!done),
                ),
              ),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8.0),
                child: MediaQuery.of(context).size.width < 400
                    ? IconButton(
                        icon: const Icon(Icons.auto_awesome),
                        tooltip: 'AI Plan',
                        onPressed: () async {
                          await DayPlanningAssistant.show(context, selectedDate, _cachedEntries, _activities);
                          await _loadUserSettings();
                        },
                      )
                    : OutlinedButton.icon(
                        onPressed: () async {
                          await DayPlanningAssistant.show(context, selectedDate, _cachedEntries, _activities);
                          await _loadUserSettings();
                        },
                        icon: const Icon(Icons.auto_awesome, size: 18),
                        label: const Text('AI Plan'),
                        style: OutlinedButton.styleFrom(
                          visualDensity: VisualDensity.compact,
                          side: BorderSide(color: Theme.of(context).primaryColor),
                        ),
                      ),
              ),
              IconButton(
                icon: const Icon(Icons.access_time),
                tooltip: 'Jump to Now',
                onPressed: _scrollToNow,
              ),
              PopupMenuButton<String>(
                tooltip: 'Customize',
                onSelected: (value) async {
                  switch (value) {
                    case 'template':
                      await Navigator.pushNamed(context, '/template');
                      if (mounted) setState(() {});
                      break;
                    case 'sleep':
                      _showSleepDialog(context);
                      break;
                    case 'signout':
                      await FirebaseAuth.instance.signOut();
                      try{ await GoogleSignIn().signOut(); } catch(_){}
                      if (mounted) {
                        Navigator.of(context).pushAndRemoveUntil(
                          MaterialPageRoute(builder: (_) => const LoginScreen()),
                          (route) => false,
                        );
                      }
                      break;
                  }
                },
                itemBuilder: (context) => [
                  const PopupMenuItem(
                    value: 'template',
                    child: ListTile(
                      leading: Icon(Icons.copy_all),
                      title: Text('Use Template'),
                      contentPadding: EdgeInsets.zero,
                    ),
                  ),
                  const PopupMenuItem(
                    value: 'sleep',
                    child: ListTile(
                      leading: Icon(Icons.bedtime),
                      title: Text('Sleep timings'),
                      contentPadding: EdgeInsets.zero,
                    ),
                  ),
                  const PopupMenuItem(
                    value: 'signout',
                    child: ListTile(
                      leading: Icon(Icons.logout),
                      title: Text('Sign out'),
                      contentPadding: EdgeInsets.zero,
                    ),
                  ),
                ],
              ),
            ],
          ),
          SliverToBoxAdapter(
            child: Column(
              children: [
                CalendarStrip(
                  selectedDate: selectedDate,
                  onDateSelected: (date) {
                    setState(() {
                      _blockKeys.clear();
                      selectedDate = date;
                      _currentDateKey = DateFormat('yyyy-MM-dd').format(selectedDate);
                      _initStream();
                      _loadDayComplete();
                    });
                    final key = DateFormat('yyyy-MM-dd').format(selectedDate);
                    final double? saved = _offsetCache[key];
                    if (saved != null) {
                      _pendingScrollOffset = saved;
                    } else {
                      _pendingScrollOffset = null;
                      WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
                    }
                  },
                  completedDates: _loggedDates,
                ),
                ValueListenableBuilder<bool>(
                  valueListenable: _habitsExpandedNotifier,
                  builder: (context, expanded, _) => ExpansionTile(
                    title: const Text('Habits'),
                    initiallyExpanded: expanded,
                    maintainState: true,
                    onExpansionChanged: (val) => _habitsExpandedNotifier.value = val,
                    children: [
                      HabitTracker(date: selectedDate),
                    ],
                  ),
                ),
              ],
            ),
          ),
                ValueListenableBuilder<TimelineViewMode>(
                  valueListenable: _viewModeNotifier,
                  builder: (context, mode, _) {
                    return SliverPersistentHeader(
                      pinned: true,
                      delegate: TimelineViewHeaderDelegate(
                        currentMode: mode,
                        onModeChanged: (newMode) => _viewModeNotifier.value = newMode,
                      ),
                    );
                  },
                ),
          StreamBuilder<QuerySnapshot>(
            key: ValueKey(_currentDateKey),
            stream: _currentStream,
            builder: _buildTimelineStream,
          ),
          const SliverPadding(padding: EdgeInsets.only(bottom: 80)),
        ],
      ),
      ),
    );
  }

  Widget _buildTimelineStream(BuildContext context, AsyncSnapshot<QuerySnapshot> snapshot) {
    if (snapshot.hasError) {
      return SliverFillRemaining(child: Center(child: Text('Error: ${snapshot.error}')));
    }
    if (!snapshot.hasData) {
      return const SliverFillRemaining(child: Center(child: CircularProgressIndicator()));
    }
    var entries = snapshot.data?.docs
            .map((doc) => TimelineEntry.fromFirestore(doc))
            .toList() ?? [];

    // Local updates handling
    final bool onlyLocalUpdates = (snapshot.data != null &&
        snapshot.data!.docChanges.isNotEmpty &&
        snapshot.data!.docChanges.every((c) => c.doc.metadata.hasPendingWrites));

    if (onlyLocalUpdates) {
      for (final change in snapshot.data!.docChanges) {
        final updated = TimelineEntry.fromFirestore(change.doc);
        final idx = _cachedEntries.indexWhere((e) => e.id == updated.id);
        switch (change.type) {
          case DocumentChangeType.removed:
            if (idx != -1) _cachedEntries.removeAt(idx);
            break;
          case DocumentChangeType.modified:
          case DocumentChangeType.added:
            if (idx == -1) {
              _cachedEntries.add(updated);
            } else {
              _cachedEntries[idx] = updated;
            }
            break;
        }
      }
      entries = _cachedEntries;
    } else {
      _cachedEntries = entries;
    }

    _splitHours = entries
        .where((e) => e.startTime.minute == 30)
        .map((e) => e.startTime.hour)
        .toSet();

    _applyTemplateIfNeeded(entries);

    final DateTime today = DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day);
    final bool isPastDate = selectedDate.isBefore(today);
    if (!isPastDate && sleepTime != null && wakeTime != null) {
      for (var hour = 0; hour < 24; hour++) {
        if (_isSleepHour(hour)) {
          _ensureSleepEntry(hour, entries);
        }
      }
    }

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_pendingScrollOffset!=null && _scrollController.hasClients) {
        final max=_scrollController.position.maxScrollExtent;
        _scrollController.jumpTo(_pendingScrollOffset!.clamp(0,max));
        _pendingScrollOffset=null;
      }
    });

    return SliverToBoxAdapter(
      child: Column(
        children: List.generate(24, (index) {
          final hour = index;

          // Section titles (Morning/Afternoon/Evening)
          String? sectionTitle;
          if(hour==6) sectionTitle = 'Morning';
          if(hour==12) sectionTitle = 'Afternoon';
          if(hour==18) sectionTitle = 'Evening';

          TimelineEntry _blank(int minute) {
            final start=DateTime(selectedDate.year,selectedDate.month,selectedDate.day,hour,minute);
            return TimelineEntry(
              id: _docId(start),
              userId: FirebaseAuth.instance.currentUser?.uid ?? '',
              date: selectedDate,
              startTime: DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, minute),
              endTime: DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, minute).add(Duration(minutes: minute==0?60:30)),
              activity: '',
              notes: '',
            );
          }

          final entry00 = entries.firstWhere(
            (e) => e.startTime.hour == hour && e.startTime.minute == 0,
            orElse: () => _blank(0),
          );

          final entry30 = _splitHours.contains(hour)
              ? entries.firstWhere(
                  (e) => e.startTime.hour == hour && e.startTime.minute == 30,
                  orElse: () => _blank(30),
                )
              : null;
          
          final key00 = _blockKeys.putIfAbsent(_noteKey(hour, 0), () => GlobalKey());
          final key30 = _splitHours.contains(hour) 
              ? _blockKeys.putIfAbsent(_noteKey(hour, 30), () => GlobalKey())
              : null;

          final tile = ValueListenableBuilder<TimelineViewMode>(
            valueListenable: _viewModeNotifier,
            builder: (context, viewMode, _) {
              return TimelineHourTile(
                key: ValueKey(hour),
                hour: hour,
                entry00: entry00,
                entry30: entry30,
                isSplit: _splitHours.contains(hour),
                viewMode: viewMode,
                onToggleSplit: () => _toggleSplit(hour),
                onUpdateEntry: _updateEntry,
                availableActivities: _flattenCats(),
                recentActivities: _recentActivities,
                onPromptCustomActivity: () => _promptCustomActivity(context),
                onUpdateRecentActivity: (act) {
                    bool changed = false;
                    if (!_recentActivities.contains(act)) {
                      _recentActivities.insert(0, act);
                      if (_recentActivities.length > 8) _recentActivities.removeLast();
                      changed = true;
                    }
                    if (!_activities.contains(act) && !_archivedActivities.contains(act)) {
                       _activities.add(act);
                       _dedupCats(); 
                       changed = true;
                    }
                    if (changed) {
                      setState(() {});
                      _saveSettings();
                    }
                },
                key00: key00,
                key30: key30,
              );
            }
          );

          if (sectionTitle != null) {
            return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal:16,vertical:8),
                  child: Text(sectionTitle, style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
                ),
                tile,
              ],
            );
          }
          return tile;
        }),
      ),
    );
  }



  Future<void> _updateEntry(TimelineEntry entry, String activity, String notes, {bool isPlan=false}) async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      final entriesColl = getFirestore()
          .collection('timeline_entries')
          .doc(user.uid)
          .collection('entries');

      final docId = _docId(entry.startTime);

      // Calculate strict end time to prevent overlaps
      DateTime newEndTime;
      if (_splitHours.contains(entry.startTime.hour)) {
        // Split hour: strictly 30 minutes
        newEndTime = entry.startTime.add(const Duration(minutes: 30));
      } else {
        // Full hour: strictly 60 minutes
        newEndTime = entry.startTime.add(const Duration(hours: 1));
      }

      final fullEntry = TimelineEntry(
        id: docId,
        userId: user.uid,
        date: entry.date,
        startTime: entry.startTime,
        endTime: newEndTime,
        planactivity: isPlan ? activity : entry.planactivity,
        planNotes: isPlan ? notes : entry.planNotes,
        activity: isPlan ? entry.activity : activity,
        notes: isPlan ? entry.notes : notes,
      );

      await entriesColl.doc(docId).set(fullEntry.toMap());
    } catch (e) {
      final messenger = ScaffoldMessenger.maybeOf(context);
      messenger?.showSnackBar(
        const SnackBar(content: Text('Unable to update entry. Please try again later.')),
      );
    }
  }

  Future<void> _showSleepDialog(BuildContext context) async {
    TimeOfDay? dialogSleep = sleepTime ?? (_sleepTimeController.text.isNotEmpty ? _parseTime(_sleepTimeController.text) : const TimeOfDay(hour: 23, minute: 0));
    TimeOfDay? dialogWake = wakeTime ?? (_wakeTimeController.text.isNotEmpty ? _parseTime(_wakeTimeController.text) : const TimeOfDay(hour: 7, minute: 0));

    final result = await showDialog(
      context: context,
      barrierDismissible: true,
      builder: (ctx) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return AlertDialog(
              title: const Text('Sleep Timings'),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      const Text('Sleep Time'),
                      TextButton(
                        onPressed: () async {
                          final t = await showTimePicker(
                            context: context,
                            initialTime: dialogSleep ?? const TimeOfDay(hour: 23, minute: 0),
                          );
                          if (t != null) {
                            setDialogState(() => dialogSleep = t);
                            _sleepTimeController.text = _fmt24(t);
                            await _saveSettings(refreshTimeline: true);
                          }
                        },
                        child: Text(dialogSleep?.format(context) ?? 'Set'),
                      ),
                    ],
                  ),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      const Text('Wake Time'),
                      TextButton(
                        onPressed: () async {
                          final t = await showTimePicker(
                            context: context,
                            initialTime: dialogWake ?? const TimeOfDay(hour: 7, minute: 0),
                          );
                          if (t != null) {
                            setDialogState(() => dialogWake = t);
                            _wakeTimeController.text = _fmt24(t);
                            await _saveSettings(refreshTimeline: true);
                          }
                        },
                        child: Text(dialogWake?.format(context) ?? 'Set'),
                      ),
                    ],
                  ),
                ],
              ),
              actions: [
                TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Close')),
              ],
            );
          },
        );
      },
    );

    // Rebuild timeline to reflect any activity changes made inside the dialog
    if (mounted && result != null) {
      setState(() {});
    }
  }

  // _showActivitiesDialog removed. Use ActivitiesManagementScreen instead.

  Future<void> _saveSettings({bool refreshTimeline = true}) async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      final settingsRef = getFirestore()
          .collection('user_settings')
          .doc(user.uid);

      _dedupCats();

      // Determine if times actually changed (compare by hour/minute not string)
      TimeOfDay _toTod(String s) => _parseTime(s);

      final prevSleep = sleepTime ?? _toTod(_sleepTimeController.text);
      final prevWake = wakeTime ?? _toTod(_wakeTimeController.text);
      final newSleep = _toTod(_sleepTimeController.text);
      final newWake = _toTod(_wakeTimeController.text);
      final bool timesChanged = prevSleep != newSleep || prevWake != newWake;

      // Persist only activities that are not part of the built-in defaults
      final Set<String> defaultSet = Set.of(kDefaultActivities);
      final List<String> customOnly = _activities.where((a) => !defaultSet.contains(a)).toList();

      await settingsRef.set({
        'sleepTime': _sleepTimeController.text,
        'wakeTime': _wakeTimeController.text,
        'customActivities': customOnly,
        'archivedActivities': _archivedActivities,
        'subActivities': _subActivities,
        'recentActivities': _recentActivities,
        'lastUpdated': FieldValue.serverTimestamp(),
      }, SetOptions(merge: true));

      // refresh local vars
      if (refreshTimeline && mounted) {
        setState(() {
          if (timesChanged) {
            sleepTime = newSleep;
            wakeTime = newWake;
          }
          // ensure Activities list refreshes in timeline & dropdown
          _activities = List<String>.from(_activities);
        });
      }

      if (timesChanged) {
        await _reconcileSleepEntriesForSelectedDate();
      }

      ScaffoldMessenger.maybeOf(context)?.showSnackBar(
        const SnackBar(content: Text('Settings saved')),
      );
    } catch (e) {
      ScaffoldMessenger.maybeOf(context)?.showSnackBar(
        const SnackBar(content: Text('Unable to save settings. Please try again later.')),
      );
    }
  }

  String _fmt24(TimeOfDay t) => '${t.hour.toString().padLeft(2, '0')}:${t.minute.toString().padLeft(2, '0')}';

  void _initStream() {
    _currentStream = getFirestore()
          .collection('timeline_entries')
          .doc(FirebaseAuth.instance.currentUser?.uid ?? '')
          .collection('entries')
          .where('date', isEqualTo: DateFormat('yyyy-MM-dd').format(selectedDate))
          .snapshots();
  }

  void _dedupCats() {
    _activities = _activities.toSet().toList();
    _archivedActivities = _archivedActivities.toSet().toList();
  }

  Future<void> _toggleSplit(int hour) async {
    final userId = FirebaseAuth.instance.currentUser?.uid;
    if (userId == null) return;
    
    final entriesColl = getFirestore()
        .collection('timeline_entries')
        .doc(userId)
        .collection('entries');

    final fullStart = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, 0);
    final fullDocId = _docId(fullStart);
    final halfStart = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, 30);
    final halfDocId = _docId(halfStart);

    final batch = getFirestore().batch();

    if (_splitHours.contains(hour)) {
      // MERGE -> remove 30-minute entry AND extend 00-entry to full hour
      batch.delete(entriesColl.doc(halfDocId));
      batch.update(entriesColl.doc(fullDocId), {
        'endTime': Timestamp.fromDate(fullStart.add(const Duration(hours: 1)))
      });

      _splitHours.remove(hour);
      _cachedEntries.removeWhere((e) => e.id == halfDocId);
      
      // Update local cache for 00 entry
      final idx = _cachedEntries.indexWhere((e) => e.id == fullDocId);
      if (idx != -1) {
        final old = _cachedEntries[idx];
        _cachedEntries[idx] = TimelineEntry(
          id: old.id, userId: old.userId, date: old.date, startTime: old.startTime,
          endTime: old.startTime.add(const Duration(hours: 1)),
          activity: old.activity, notes: old.notes,
          planactivity: old.planactivity, planNotes: old.planNotes
        );
      }

    } else {
      // SPLIT -> add 30-minute entry AND shrink 00-entry to 30 mins
      
      // 1. Create 30-min entry
      final newEntry = TimelineEntry(
        id: halfDocId,
        userId: userId,
        date: selectedDate,
        startTime: halfStart,
        endTime: halfStart.add(const Duration(minutes: 30)),
        activity: '',
        notes: '',
      );
      batch.set(entriesColl.doc(halfDocId), newEntry.toMap());

      // 2. Shrink 00-min entry
      // We must ensure 00-entry exists. If it doesn't (visual blank), we should create it.
      // But _blank() is visual only. 
      // The user clicked "split", implies they want to edit.
      // If 00 doesn't exist in DB, we should create it now.
      
      final idx = _cachedEntries.indexWhere((e) => e.id == fullDocId);
      if (idx == -1) {
        // Create 00 entry as well
        final entry00 = TimelineEntry(
          id: fullDocId,
          userId: userId,
          date: selectedDate,
          startTime: fullStart,
          endTime: fullStart.add(const Duration(minutes: 30)), // shrink immediately
          activity: '',
          notes: '',
        );
        batch.set(entriesColl.doc(fullDocId), entry00.toMap());
        _cachedEntries.add(entry00);
      } else {
        // Update existing
        batch.update(entriesColl.doc(fullDocId), {
          'endTime': Timestamp.fromDate(fullStart.add(const Duration(minutes: 30)))
        });
        final old = _cachedEntries[idx];
        _cachedEntries[idx] = TimelineEntry(
          id: old.id, userId: old.userId, date: old.date, startTime: old.startTime,
          endTime: old.startTime.add(const Duration(minutes: 30)),
          activity: old.activity, notes: old.notes,
          planactivity: old.planactivity, planNotes: old.planNotes
        );
      }

      _splitHours.add(hour);
      _cachedEntries.add(newEntry);
    }

    await batch.commit();

  }

  String _noteKey(int hour, int minute) => '${hour.toString().padLeft(2,'0')}:${minute.toString().padLeft(2,'0')}';

  String _dateStr(DateTime d)=>DateFormat('yyyy-MM-dd').format(d);

  Future<void> _loadDayComplete() async{
    final uid=FirebaseAuth.instance.currentUser?.uid; if(uid==null) return;
    final doc=await getFirestore().collection('daily_logs').doc(uid).collection('logs').doc(_dateStr(selectedDate)).get();
    _dayCompleteNotifier.value = doc.exists && (doc.data()?['complete']==true);
  }

  Future<void> _setDayComplete(bool val) async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;

    // Optimistically update UI immediately
    _dayCompleteNotifier.value = val;

    final ref = getFirestore()
        .collection('daily_logs')
        .doc(uid)
        .collection('logs')
        .doc(_dateStr(selectedDate));

    try {
      if (val) {
        await ref.set({
          'date': _dateStr(selectedDate),
          'complete': true,
          'lastUpdated': FieldValue.serverTimestamp(),
        });
        _loggedDates.add(_dateStr(selectedDate));
      } else {
        await ref.delete();
        _loggedDates.remove(_dateStr(selectedDate));
      }
    } catch (e) {
      // Revert on failure and inform user
      _dayCompleteNotifier.value = !val;
      ScaffoldMessenger.maybeOf(context)?.showSnackBar(
        const SnackBar(content: Text('Could not update day status. Please try again.')),
      );
    }
  }

  // ---------- Sub-activity helpers ----------
  Future<void> _addSubactivity(String parent, String sub) async {
    if (sub.trim().isEmpty) return;
    if (!_activities.contains(parent)) {
      _activities.add(parent);
    }
    final list = _subActivities[parent] ?? <String>[];
    if (!list.contains(sub)) {
      list.add(sub);
      _subActivities[parent] = list;
      await _saveSettings(refreshTimeline: true);

      final double offset=_scrollController.hasClients?_scrollController.offset:0;
      if (mounted) setState(() {});
      WidgetsBinding.instance.addPostFrameCallback((_){
        if(_scrollController.hasClients){
          _scrollController.jumpTo(offset.clamp(0,_scrollController.position.maxScrollExtent));
        }
      });
    }
  }

  Future<void> _removeSubactivity(String parent, String sub) async {
    final list = _subActivities[parent];
    if (list == null) return;
    list.remove(sub);
    if (list.isEmpty) {
      _subActivities.remove(parent);
    } else {
      _subActivities[parent] = list;
    }
    await _saveSettings(refreshTimeline: true);
    final double offset=_scrollController.hasClients?_scrollController.offset:0;
    if (mounted) setState(() {});
    WidgetsBinding.instance.addPostFrameCallback((_){
      if(_scrollController.hasClients){
        _scrollController.jumpTo(offset.clamp(0,_scrollController.position.maxScrollExtent));
      }
    });
  }

  Future<void> _applyTemplateIfNeeded(List<TimelineEntry> currentEntries) async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;
    // Only today or future
    final DateTime today = DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day);
    if (selectedDate.isBefore(today)) return;
    if (_dayComplete) return; // don't overwrite completed day

    QuerySnapshot tmplSnap;

    // Fetch user templates matches
    final tmplQuery = await getFirestore()
        .collection('user_templates')
        .doc(uid)
        .collection('templates')
        .where('daysOfWeek', arrayContains: selectedDate.weekday)
        .get();

    if (tmplQuery.docs.isNotEmpty) {
      // Use the first matching template
      final tmplId = tmplQuery.docs.first.id;
      tmplSnap = await getFirestore()
          .collection('user_templates')
          .doc(uid)
          .collection('templates')
          .doc(tmplId)
          .collection('entries')
          .get();
    } else {
      // Try to fallback to "Default" or legacy if no specific day match?
      // Actually, if we migrated everything to "Default" (days 1-7), the above query should catch it if they didn't change it.
      // But if they created a specific one and removed days from default, we might have gaps.
      // If no template matches this day, we do nothing.
      
      // However, check for LEGACY (pre-migration) just in case user didn't open templates screen yet
      final legacyColl = getFirestore().collection('template_entries').doc(uid).collection('entries');
      tmplSnap = await legacyColl.get();
      if (tmplSnap.docs.isEmpty) return; // No legacy either
    }

    if (tmplSnap.docs.isEmpty) {
      return; // no template entries found in the matching template
    }

    final Map<String, TimelineEntry> existingMap = {
      for (var e in currentEntries) _noteKey(e.startTime.hour, e.startTime.minute): e
    };

    final batch = getFirestore().batch();
    final entriesColl = getFirestore().collection('timeline_entries').doc(uid).collection('entries');

    for (final doc in tmplSnap.docs) {
      final hour = int.parse(doc.id.substring(0, 2));
      final minute = int.parse(doc.id.substring(2));
      final key = _noteKey(hour, minute);
      final data = doc.data() as Map<String, dynamic>; // Safely cast
      final tmplPlanCat = data['planactivity'] ?? data['activity'] ?? '';
      final tmplPlanNotes = data['planNotes'] ?? data['notes'] ?? '';
      final tmplRetroCat = (data['activity'] ?? '') == 'Sleep' ? 'Sleep' : '';
      final tmplRetroNotes = tmplRetroCat.isNotEmpty ? (data['notes'] ?? '') : '';

      if (existingMap.containsKey(key)) {
        final existing = existingMap[key]!;
        final Map<String,dynamic> upd={};
        if(existing.planactivity.isEmpty){
          upd['planactivity']=tmplPlanCat; upd['planNotes']=tmplPlanNotes; }
        if(tmplRetroCat.isNotEmpty && existing.activity.isEmpty){
          upd['activity']=tmplRetroCat; upd['notes']=tmplRetroNotes; }
        if(upd.isNotEmpty){batch.update(entriesColl.doc(existing.id),upd);}        
        continue;
      }

      final start = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, minute);
      final newEntry = TimelineEntry(
        id: _docId(start),
        userId: uid,
        date: selectedDate,
        startTime: start,
        endTime: start.add(Duration(minutes: minute == 0 ? 60 : 30)),
        planactivity: tmplPlanCat,
        planNotes: tmplPlanNotes,
        activity: tmplRetroCat,
        notes: tmplRetroNotes,
      );
      batch.set(entriesColl.doc(newEntry.id), newEntry.toMap());
    }
    await batch.commit();
  }

  List<String> _flattenCats() {
    final flatSet = <String>{};
    void addParent(String parent) {
      flatSet.add(parent);
      final subs = _subActivities[parent] ?? [];
      for (final s in subs) {
        flatSet.add('$parent / $s');
      }
    }

    for (final parent in _activities) {
      addParent(parent);
    }

    final DateTime today = DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day);
    if (selectedDate.isBefore(today)) {
      for (final parent in _archivedActivities) {
        addParent(parent);
      }
    }

    return flatSet.toList();
  }

  Future<String?> _promptCustomActivity(BuildContext context) async {
    final TextEditingController ctrl = TextEditingController();
    return showDialog<String>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Custom activity'),
        content: TextField(
          controller: ctrl,
          autofocus: true,
          decoration: const InputDecoration(hintText: 'Enter activity'),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),
          TextButton(onPressed: () => Navigator.pop(ctx, ctrl.text.trim()), child: const Text('OK')),
        ],
      ),
    );
  }

  void _updateRecent(String act) {
    _recentActivities.remove(act);
    _recentActivities.insert(0, act);
    if (_recentActivities.length > 8) {
      _recentActivities = _recentActivities.sublist(0, 8);
    }
    final user = FirebaseAuth.instance.currentUser;
    if (user != null) {
      getFirestore()
          .collection('user_settings')
          .doc(user.uid)
          .set({'recentActivities': _recentActivities}, SetOptions(merge: true));
    }
  }

  Future<void> _loadLoggedDates() async {
    final uid=FirebaseAuth.instance.currentUser?.uid; if(uid==null) return;
    final today=DateTime.now();
    final start=today.subtract(const Duration(days:7));
    final end=today.add(const Duration(days:7));
    final snap=await getFirestore().collection('daily_logs').doc(uid).collection('logs')
      .where('date', isGreaterThanOrEqualTo: DateFormat('yyyy-MM-dd').format(start))
      .where('date', isLessThanOrEqualTo: DateFormat('yyyy-MM-dd').format(end))
      .get();
    _loggedDates = snap.docs.map((d)=>d.id).toSet();
    if(mounted) setState((){});
  }
}