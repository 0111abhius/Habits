import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

import 'social_screen.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'profile_screen.dart';
import '../models/timeline_entry.dart';
import '../widgets/calendar_strip.dart';
import '../widgets/habit_tracker.dart';
import '../main.dart';  // Import for getFirestore()
import 'package:intl/intl.dart';
import 'dart:async';
import '../utils/activities.dart';

import '../widgets/timeline_hour_tile.dart';
import 'day_planning_assistant.dart';
import '../models/timeline_view_mode.dart';
import '../widgets/timeline_view_header.dart';

import '../models/daily_score.dart';
import '../models/daily_log.dart';
import '../models/user_settings.dart';
import '../services/score_service.dart';
import '../models/ai_proposal.dart';
import '../widgets/day_score_dialog.dart';
import '../services/smart_coach_service.dart';
import '../widgets/coach_card.dart';

class TimelineScreen extends StatefulWidget {
  const TimelineScreen({super.key});

  @override
  State<TimelineScreen> createState() => _TimelineScreenState();
}

class _TimelineScreenState extends State<TimelineScreen> with WidgetsBindingObserver {
  DateTime selectedDate = DateTime.now();
  static const List<String> _protectedActivities = ['Sleep'];
  List<String> _activities = List.from(kDefaultActivities);

  String _displayLabel(String act) => displayActivity(act);

  List<String> _archivedActivities = []; // Activities removed from active but kept for history
  Map<String, List<String>> _subActivities = {}; // parent -> list of subs

  TimeOfDay? wakeTime;
  TimeOfDay? sleepTime;
  late final ScrollController _scrollController;
  final TextEditingController _sleepTimeController = TextEditingController();
  final TextEditingController _wakeTimeController = TextEditingController();

  double? _pendingScrollOffset;

  Set<int> _splitHours = {}; // hours that have a 30-minute split for the selected date
  // Cache of the most recently rendered entries list. This lets us re-use the
  // previous UI when the only Firestore changes are still pending writes
  // generated by this device â€“ preventing a visible full list refresh.
  List<TimelineEntry> _cachedEntries = [];

  final ValueNotifier<bool> _habitsExpandedNotifier = ValueNotifier(true);
  final ValueNotifier<TimelineViewMode> _viewModeNotifier = ValueNotifier(TimelineViewMode.plan);

  bool get _habitsExpanded => _habitsExpandedNotifier.value;
  TimelineViewMode get _viewMode => _viewModeNotifier.value;

  // Using a ValueNotifier means toggling the "Day fully logged" checkbox
  // only rebuilds that specific part of the UI instead of the whole timeline.
  final ValueNotifier<bool> _dayCompleteNotifier = ValueNotifier(false);

  // Convenience getter so existing read-access sites keep working.
  bool get _dayComplete => _dayCompleteNotifier.value;

  final Map<String, GlobalKey> _blockKeys = {};
  static final Map<String, double> _offsetCache = {}; // keyed by yyyy-MM-dd (selected date)
  late String _currentDateKey;

  List<String> _recentActivities = [];

  Set<String> _loggedDates = {};
  late Stream<QuerySnapshot> _currentStream;
  
  final ValueNotifier<List<String>> _recentActivitiesNotifier = ValueNotifier([]);

  // Historical data for suggestions
  List<TimelineEntry> _yesterdayEntries = [];
  List<TimelineEntry> _lastWeekEntries = [];

  // Overview Data

  DateTime? _lastPlannedAt;
  DailyScore? _dailyScore;
  bool _isCalculatingScore = false;
  String? _morningBrief;
  CoachInsight? _coachInsight;
  bool _coachDismissed = false;
  bool _calendarVisible = false;
  bool _isAIPlanning = false;
  Map<String, AIProposal> _aiProposals = {};


  Map<String, String> _sectionNotes = {}; // Morning, Afternoon, Evening notes
  final Map<String, TextEditingController> _sectionControllers = {};
  final Map<String, Timer> _sectionDebouncers = {};

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _currentDateKey = DateFormat('yyyy-MM-dd').format(selectedDate);
    _initStream();
    _scrollController = ScrollController(initialScrollOffset: _offsetCache[_currentDateKey] ?? 0)
      ..addListener(() {
        _offsetCache[_currentDateKey] = _scrollController.offset;
        if (_calendarVisible && _scrollController.position.activity!.isScrolling) {
          setState(() {
            _calendarVisible = false;
          });
        }
      });
    _loadUserSettings();
    _loadDayComplete();
    _loadLoggedDates();
    _loadHistoricalData();
    _loadCoachInsight();
  }

  @override
  void reassemble() {
    super.reassemble();
    // Clear global keys on hot reload to prevent "Duplicate GlobalKey" issues if widget tree structure changes
    _blockKeys.clear();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _dayCheckTimer?.cancel();
    _scrollController.dispose();
    _sleepTimeController.dispose();
    _wakeTimeController.dispose();
    _pendingScrollOffset=null;
    for (var c in _sectionControllers.values) c.dispose();
    for (var t in _sectionDebouncers.values) t.cancel();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      _checkForDayChange();
      // Also refresh settings/data that might have changed elsewhere or need refreshing
      _initStream(); 
      _loadUserSettings();
    }
  }

  Timer? _dayCheckTimer;

  void _checkForDayChange() {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final selectedDiff = DateTime(selectedDate.year, selectedDate.month, selectedDate.day);
    
    // Check if the displayed date is "Yesterday" relative to real-world Today.
    // This implies the day rolled over.
    if (selectedDiff == today.subtract(const Duration(days: 1))) {
      // Auto-advance to Today
       setState(() {
         _blockKeys.clear();
         selectedDate = today;
         _currentDateKey = DateFormat('yyyy-MM-dd').format(selectedDate);
         _initStream();
         _loadDayComplete();
         _loadHistoricalData();
         // Reset scroll to wake time since it's a "new" day view
         _pendingScrollOffset = null;
         WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
       });
    } else if (selectedDiff == today) {
       // If we are already on today, just triggering setState (via other methods or explicit) 
       // updates the UI relative time labels if needed, but setState here is safe too.
       // However, we only need to force update if something stale is visible.
       // Minimal refresh:
       if (mounted) setState(() {});
    }
    }

  Future<void> _loadCoachInsight() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) return;
    
    // Only load insight if looking at "Today"
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    if (selectedDate.isBefore(today)) return;

    // Simple heuristic: don't annoy.
    if (_coachDismissed) return;

    final insight = await SmartCoachService().generateInsight(user.uid);
    if (mounted && insight != null) {
      setState(() {
        _coachInsight = insight;
      });
    }
  }

  // Helper to parse 'HH:mm' strings to TimeOfDay
  TimeOfDay _parseTime(String s) {
    final parts = s.split(':');
    return TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1]));
  }

  Future<void> _loadHistoricalData() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) return;

    final entriesColl = getFirestore()
        .collection('timeline_entries')
        .doc(user.uid)
        .collection('entries');

    // 1. Yesterday
    final yesterday = selectedDate.subtract(const Duration(days: 1));
    final yStr = DateFormat('yyyy-MM-dd').format(yesterday);
    final ySnap = await entriesColl.where('date', isEqualTo: yStr).get();
    
    // 2. Same day last week
    final lastWeek = selectedDate.subtract(const Duration(days: 7));
    final wStr = DateFormat('yyyy-MM-dd').format(lastWeek);
    final wSnap = await entriesColl.where('date', isEqualTo: wStr).get();

    // 3. Fetch Yesterday's Daily Log for Morning Brief
    try {
       final yLogDoc = await getFirestore()
          .collection('daily_logs')
          .doc(user.uid)
          .collection('logs')
          .doc(yStr)
          .get();
       
       if (yLogDoc.exists && yLogDoc.data()!.containsKey('scoreDetails')) {
         final details = yLogDoc.data()!['scoreDetails'] as Map<String, dynamic>;
         final tip = details['coachTip'] as String?;
         if (tip != null && tip.isNotEmpty) {
           _morningBrief = tip;
         }
       }
    } catch (_) {}

    if (mounted) {
      setState(() {
        _yesterdayEntries = ySnap.docs.map((d) => TimelineEntry.fromFirestore(d)).toList();
        _lastWeekEntries = wSnap.docs.map((d) => TimelineEntry.fromFirestore(d)).toList();
      });
    }
  }

  List<String> _getSuggestionsForHour(int hour) {
    // Return only explicit history matches (Yesterday/LastWeek same hour)
    // The Tile handles backfilling from general recents.
    
    final Set<String> candidates = {};
    
    // Check last week
    final lastWeekEntry = _lastWeekEntries.firstWhere(
      (e) => e.startTime.hour == hour && e.activity.isNotEmpty && e.activity != 'Sleep',
      orElse: () => TimelineEntry.empty(),
    );
    if (lastWeekEntry.activity.isNotEmpty) {
      candidates.add(lastWeekEntry.activity);
    }
    
    // Check yesterday
    final yesterdayEntry = _yesterdayEntries.firstWhere(
      (e) => e.startTime.hour == hour && e.activity.isNotEmpty && e.activity != 'Sleep',
      orElse: () => TimelineEntry.empty(),
    );
    if (yesterdayEntry.activity.isNotEmpty) {
      candidates.add(yesterdayEntry.activity);
    }
    
    return candidates.toList();
  }

  Future<void> _reconcileSleepEntriesForSelectedDate() async {
    if (sleepTime == null || wakeTime == null) return;
    // Do not modify historical data: only reconcile for today or future
    final DateTime today = DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day);
    if (selectedDate.isBefore(today)) return;
    final userId = FirebaseAuth.instance.currentUser?.uid;
    if (userId == null) return;

    final entriesColl = getFirestore()
        .collection('timeline_entries')
        .doc(userId)
        .collection('entries');

    final dateStr = DateFormat('yyyy-MM-dd').format(selectedDate);
    final snapshot = await entriesColl.where('date', isEqualTo: dateStr).get();
    final entries = snapshot.docs.map((d) => TimelineEntry.fromFirestore(d)).toList();

    for (var hour = 0; hour < 24; hour++) {
      final shouldSleep = _isSleepHour(hour);
      final matching = entries.where((e) => e.startTime.hour == hour);
      final TimelineEntry? existing = matching.isNotEmpty ? matching.first : null;

      final start = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour);
      final id = _docId(start);

      if (shouldSleep) {
        // ensure a placeholder exists but DO NOT override if user already set another activity
        if (existing == null) {
          final newEntry = TimelineEntry(
            id: id,
            userId: userId,
            date: selectedDate,
            startTime: start,
            endTime: start.add(const Duration(hours: 1)),
            activity: 'Sleep',
            notes: '',
          );
          await entriesColl.doc(id).set(newEntry.toMap(), SetOptions(merge: true));
        } else if (existing.activity.isEmpty) {
          // only auto-fill if user hasn't picked something yet
          await entriesColl.doc(existing.id).update({'activity': 'Sleep'});
        }
      } else {
        // should NOT be sleep
        if (existing != null && existing.activity == 'Sleep') {
          await entriesColl.doc(existing.id).update({'activity': ''});
        }
      }
    }
  }

  Future<void> _loadUserSettings() async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      final settingsRef = getFirestore()
          .collection('user_settings')
          .doc(user.uid);

      final settings = await settingsRef.get();
      if (settings.exists) {
        final data = settings.data()!;
        final sleepTxt = data['sleepTime'] ?? '23:00';
        final wakeTxt = data['wakeTime'] ?? '7:00';

        setState(() {
          _sleepTimeController.text = sleepTxt;
          _wakeTimeController.text = wakeTxt;
          sleepTime = _parseTime(sleepTxt);
          wakeTime = _parseTime(wakeTxt);
          final List<String> customActs = List<String>.from(data['customActivities'] ?? []);
          _recentActivities = List<String>.from(data['recentActivities'] ?? []);
          // Always include the built-in defaults, then any user custom ones
          _activities = [
            ...kDefaultActivities,
            ...customActs,
          ];
          _archivedActivities = List<String>.from(data['archivedActivities'] ?? []);
          _subActivities = (data['subActivities'] as Map<String, dynamic>? ?? {})
              .map((k, v) => MapEntry(k, List<String>.from(v as List)));
          _recentActivitiesNotifier.value = List.from(_recentActivities);
          _dedupCats();
          // ensure 'Sleep' is always present
          if (!_activities.contains('Sleep')) {
            _activities.insert(0,'Sleep');
          }
        });

        WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
        await _reconcileSleepEntriesForSelectedDate();
      } else {
        // Initialize with default settings if none exist
        await settingsRef.set({
          'sleepTime': '23:00',
          'wakeTime': '7:00',
          // Start with no custom activities; built-in defaults are always present client-side
          'customActivities': [],
          'archivedActivities': [],
          'recentActivities': [],
          'lastUpdated': FieldValue.serverTimestamp(),
        });
        setState(() {
          _sleepTimeController.text = '23:00';
          _wakeTimeController.text = '7:00';
          _activities = List.from(kDefaultActivities);
          _archivedActivities = [];
          _recentActivities = [];
          _recentActivitiesNotifier.value = [];
          _dedupCats();
        });
        WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
        await _reconcileSleepEntriesForSelectedDate();
      }
    } catch (e) {
      if (!mounted) return;
      final messenger = ScaffoldMessenger.maybeOf(context);
      messenger?.showSnackBar(
        const SnackBar(content: Text('Unable to load settings. Please try again later.')),
      );
    }
  }

  Future<void> _scrollToNow() async {
    final now = DateTime.now();
    final int hour = now.hour;
    // If it's effectively 30 min block (>= 30) AND that hour is split, scroll to :30
    // But if hour not split, :30 doesn't exist, so scroll to :00
    final bool target30 = _splitHours.contains(hour) && now.minute >= 30;
    final id = _noteKey(hour, target30 ? 30 : 0);

    final key = _blockKeys[id];
    if (key?.currentContext != null) {
      Scrollable.ensureVisible(
        key!.currentContext!,
        duration: const Duration(milliseconds: 500),
        curve: Curves.easeInOut,
        alignment: 0.1, // slightly below top
      );
    }
  }

  void _scrollToWakeTime() {
    if (wakeTime == null) return;
    // same logic, assume wake time is usually on the hour, but if we stored minutes implies precision
    // For simplicity, simplest approximation
    final id = _noteKey(wakeTime!.hour, 0);
    final key = _blockKeys[id];
    if (key?.currentContext != null) {
       Scrollable.ensureVisible(
        key!.currentContext!,
        alignment: 0.1,
      );
    } else {
      // if not mounted yet? Should unlikely be the case with SingleChildScrollView 
      // unless frame hasn't built.
       WidgetsBinding.instance.addPostFrameCallback((_) {
         if (key?.currentContext != null) {
            Scrollable.ensureVisible(
              key!.currentContext!,
              alignment: 0.1,
            );
         }
       });
    }
  }

  bool _isSleepHour(int hour) {
    if (sleepTime == null || wakeTime == null) return false;
    final sleepHour = sleepTime!.hour;
    final wakeHour = wakeTime!.hour;
    if (sleepHour < wakeHour) {
      return hour >= sleepHour && hour < wakeHour;
    } else {
      // Sleep crosses midnight
      return hour >= sleepHour || hour < wakeHour;
    }
  }

  String _docId(DateTime dt) => DateFormat('yyyyMMdd_HHmm').format(dt);

  Future<void> _ensureSleepEntry(int hour, List<TimelineEntry> existingEntries) async {
    final alreadyExists = existingEntries.any((e) => e.startTime.hour == hour);
    if (alreadyExists) return;
    final userId = FirebaseAuth.instance.currentUser?.uid;
    if (userId == null) return;
    final start = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour);
    final newEntry = TimelineEntry(
      id: _docId(start),
      userId: userId,
      date: selectedDate,
      startTime: start,
      endTime: start.add(const Duration(hours: 1)),
      activity: 'Sleep',
      notes: '',
    );
    final entriesColl = getFirestore()
        .collection('timeline_entries')
        .doc(userId)
        .collection('entries');
    await entriesColl.doc(newEntry.id).set(newEntry.toMap(), SetOptions(merge: true));
  }

  String _getDateTitle(DateTime date) {
    return DateFormat('EEE').format(date);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Stack(
        children: [
          Positioned.fill(child: 
            Column(
              children: [
                Expanded(child: Stack(
                  children: [
                    GestureDetector(
            onHorizontalDragEnd: (details) {
          if (details.primaryVelocity == null) return;
          const double sensitivity = 300.0;
          
          if (details.primaryVelocity! < -sensitivity) {
            // Swipe Left -> Next Day
            final nextDay = selectedDate.add(const Duration(days: 1));
            setState(() {
              _blockKeys.clear();
              selectedDate = nextDay;
              _currentDateKey = DateFormat('yyyy-MM-dd').format(selectedDate);
              _initStream();
              _loadDayComplete();
              _loadHistoricalData();
              _calendarVisible = false;
            });
            // Reset scroll/cache
            _pendingScrollOffset = null;
            WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
          } else if (details.primaryVelocity! > sensitivity) {
            // Swipe Right -> Previous Day
             final prevDay = selectedDate.subtract(const Duration(days: 1));
             setState(() {
              _blockKeys.clear();
              selectedDate = prevDay;
              _currentDateKey = DateFormat('yyyy-MM-dd').format(selectedDate);
              _initStream();
              _loadDayComplete();
              _loadHistoricalData();
              _calendarVisible = false;
            });
            // Reset scroll/cache
            _pendingScrollOffset = null;
            WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
          }
        },
        child: CustomScrollView(
        controller: _scrollController,
        slivers: [
          SliverAppBar(
            pinned: true,
            title: GestureDetector(
              onTap: () {
                setState(() {
                  _calendarVisible = !_calendarVisible;
                });
              },
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(_getDateTitle(selectedDate), style: const TextStyle(fontWeight: FontWeight.bold)),
                  const SizedBox(width: 4),
                  Icon(
                    _calendarVisible ? Icons.expand_less : Icons.expand_more,
                    size: 20,
                  ),
                ],
              ),
            ),
            actions: [
              ValueListenableBuilder<bool>(
                valueListenable: _dayCompleteNotifier,
                builder: (context, done, _) => IconButton(
                  icon: Icon(
                    done ? Icons.check_circle : Icons.check_circle_outline,
                    color: done ? Colors.green : null,
                  ),
                  tooltip: done ? 'Day Logged' : 'Mark Day as Logged',
                  onPressed: () => _setDayComplete(!done),
                ),
              ),
              IconButton(
                icon: Badge(
                  isLabelVisible: (_coachInsight != null && !_coachDismissed) || (_morningBrief != null && !_coachDismissed), // Simplified logic: dot if there are "new" things
                  smallSize: 8,
                  child: const Icon(Icons.lightbulb_outline),
                ),
                tooltip: 'Daily Briefing',
                onPressed: () => _showDailyBriefing(context),
              ),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8.0),
                child: ValueListenableBuilder<bool>(
                  valueListenable: _dayCompleteNotifier,
                  builder: (context, done, _) {
                    if (done) {
                      return MediaQuery.of(context).size.width < 400
                          ? IconButton(
                              icon: _isCalculatingScore 
                                  ? const SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 2)) 
                                  : Icon(_dailyScore != null ? Icons.score : Icons.analytics_outlined),
                              tooltip: 'Day Score',
                              onPressed: _calculateAndShowScore,
                            )
                          : OutlinedButton.icon(
                              onPressed: _calculateAndShowScore,
                              icon: _isCalculatingScore 
                                  ? const SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 2)) 
                                  : Icon(_dailyScore != null ? Icons.score : Icons.analytics_outlined, size: 18),
                              label: Text(_isCalculatingScore ? 'Calculating...' : (_dailyScore != null ? 'Score: ${_dailyScore!.totalScore}' : 'Day Score')),
                              style: OutlinedButton.styleFrom(
                                visualDensity: VisualDensity.compact,
                                side: BorderSide(color: Theme.of(context).primaryColor),
                                backgroundColor: _dailyScore != null ? Theme.of(context).primaryColor.withOpacity(0.1) : null,
                              ),
                            );
                    } else {
                      // Show AI Plan
                      return MediaQuery.of(context).size.width < 400
                          ? IconButton(
                              icon: _isAIPlanning 
                                  ? const SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 2))
                                  : const Icon(Icons.auto_awesome),
                              tooltip: 'AI Plan',
                              onPressed: _isAIPlanning ? null : () async {
                                final proposals = await DayPlanningAssistant.show(
                                  context, 
                                  selectedDate, 
                                  _cachedEntries, 
                                  _activities,
                                  onLoading: (isLoading) {
                                    if (mounted) setState(() => _isAIPlanning = isLoading);
                                  }
                                );
                                if (proposals != null && proposals.isNotEmpty) {
                                  if (mounted) setState(() => _aiProposals = proposals);
                                }
                                await _loadUserSettings();
                              },
                            )
                          : OutlinedButton.icon(
                              onPressed: _isAIPlanning ? null : () async {
                                final proposals = await DayPlanningAssistant.show(
                                  context, 
                                  selectedDate, 
                                  _cachedEntries, 
                                  _activities,
                                  onLoading: (isLoading) {
                                    if (mounted) setState(() => _isAIPlanning = isLoading);
                                  }
                                );
                                if (proposals != null && proposals.isNotEmpty) {
                                  if (mounted) setState(() => _aiProposals = proposals);
                                }
                                await _loadUserSettings();
                              },
                              icon: _isAIPlanning 
                                  ? const SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 2))
                                  : const Icon(Icons.auto_awesome, size: 18),
                              label: Text(_isAIPlanning ? 'Planning...' : 'AI Plan'),
                              style: OutlinedButton.styleFrom(
                                visualDensity: VisualDensity.compact,
                                side: BorderSide(color: Theme.of(context).primaryColor),
                              ),
                            );
                    }
                  }
                ),
              ),
              PopupMenuButton<String>(
                icon: const Icon(Icons.more_vert),
                tooltip: 'More Options',
                onSelected: (value) async {
                  if (value == 'jump_to_now') {
                    _scrollToNow();
                  } else if (value == 'community') {
                    Navigator.push(context, MaterialPageRoute(builder: (_) => const SocialScreen()));
                  } else if (value == 'template') {
                    await Navigator.pushNamed(context, '/template');
                    if (mounted) setState(() {});
                  } else if (value == 'clear_all') {
                    final confirm = await showDialog<bool>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                        title: const Text('Clear all activities?'),
                        content: const Text('This will remove all logged and planned activities for this day. This cannot be undone.'),
                        actions: [
                          TextButton(onPressed: () => Navigator.pop(ctx, false), child: const Text('Cancel')),
                          TextButton(onPressed: () => Navigator.pop(ctx, true), child: const Text('Clear All', style: TextStyle(color: Colors.red))),
                        ],
                      ),
                    );
                    if (confirm == true) {
                      await _clearTimeline(keepSleep: false);
                    }
                  } else if (value == 'clear_except_sleep') {
                    final confirm = await showDialog<bool>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                        title: const Text('Clear except Sleep?'),
                        content: const Text('This will remove all activities except Sleep. This cannot be undone.'),
                        actions: [
                          TextButton(onPressed: () => Navigator.pop(ctx, false), child: const Text('Cancel')),
                          TextButton(onPressed: () => Navigator.pop(ctx, true), child: const Text('Clear', style: TextStyle(color: Colors.red))),
                        ],
                      ),
                    );
                    if (confirm == true) {
                      await _clearTimeline(keepSleep: true);
                    }
                  }
                },
                itemBuilder: (BuildContext context) => <PopupMenuEntry<String>>[
                  const PopupMenuItem<String>(
                    value: 'jump_to_now',
                    child: Row(
                      children: [
                        Icon(Icons.access_time, size: 20),
                        SizedBox(width: 12),
                        Text('Jump to Now'),
                      ],
                    ),
                  ),
                  const PopupMenuItem<String>(
                    value: 'community',
                    child: Row(
                      children: [
                        Icon(Icons.people, size: 20),
                        SizedBox(width: 12),
                        Text('Community'),
                      ],
                    ),
                  ),
                  const PopupMenuItem<String>(
                    value: 'template',
                    child: Row(
                      children: [
                        Icon(Icons.copy_all, size: 20),
                        SizedBox(width: 12),
                        Text('Use Template'),
                      ],
                    ),
                  ),
                  const PopupMenuDivider(),
                  const PopupMenuItem<String>(
                    value: 'clear_except_sleep',
                    child: Row(
                      children: [
                        Icon(Icons.cleaning_services_outlined, size: 20),
                        SizedBox(width: 12),
                        Text('Clear except Sleep'),
                      ],
                    ),
                  ),
                  const PopupMenuItem<String>(
                    value: 'clear_all',
                    child: Row(
                      children: [
                        Icon(Icons.delete_outline, size: 20, color: Colors.red),
                        SizedBox(width: 12),
                        Text('Clear All', style: TextStyle(color: Colors.red)),
                      ],
                    ),
                  ),
                ],
              ),
              StreamBuilder<User?>(
                stream: FirebaseAuth.instance.authStateChanges(),
                builder: (context, snapshot) {
                  final user = snapshot.data;
                  final String initials = (user?.displayName?.isNotEmpty ?? false)
                      ? user!.displayName!.trim().split(' ').take(2).map((e) => e[0].toUpperCase()).join()
                      : '?';
                  return Padding(
                    padding: const EdgeInsets.only(left: 8.0, right: 16.0),
                    child: GestureDetector(
                      onTap: () async {
                        await Navigator.push(
                         context,
                         MaterialPageRoute(builder: (context) => const ProfileScreen()),
                        );
                        if (mounted) {
                          _loadUserSettings();
                          _initStream();
                        }
                      },
                      child: CircleAvatar(
                        radius: 16,
                        backgroundColor: Theme.of(context).primaryColor,
                        backgroundImage: user?.photoURL != null ? NetworkImage(user!.photoURL!) : null,
                        child: user?.photoURL == null
                            ? Text(initials, style: const TextStyle(fontSize: 12, color: Colors.white, fontWeight: FontWeight.bold))
                            : null,
                      ),
                    ),
                  );
                },
              ),
            ],
          ),
          SliverToBoxAdapter(
            child: Column(
              children: [
                // CalendarStrip removed from here
                ValueListenableBuilder<bool>(
                  valueListenable: _habitsExpandedNotifier,
                  builder: (context, expanded, _) => ExpansionTile(
                    title: const Text('Habits'),
                    initiallyExpanded: expanded,
                    maintainState: true,
                    onExpansionChanged: (val) => _habitsExpandedNotifier.value = val,
                    children: [
                      HabitTracker(date: selectedDate),
                    ],
                  ),
                ),
              ],
            ),
          ),
                ValueListenableBuilder<TimelineViewMode>(
                  valueListenable: _viewModeNotifier,
                  builder: (context, mode, _) {
                    return SliverPersistentHeader(
                      pinned: true,
                      delegate: TimelineViewHeaderDelegate(
                        currentMode: mode,
                        onModeChanged: (newMode) => _viewModeNotifier.value = newMode,
                      ),
                    );
                  },
                ),
          StreamBuilder<QuerySnapshot>(
            key: ValueKey(_currentDateKey),
            stream: _currentStream,
            builder: _buildTimelineStream,
          ),
          const SliverPadding(padding: EdgeInsets.only(bottom: 80)),
        ],
      ),
      ),
      if (_calendarVisible)
        Positioned(
          top: MediaQuery.of(context).padding.top + kToolbarHeight,
          left: 0,
          right: 0,
          child: Material(
            elevation: 4,
            color: Theme.of(context).scaffoldBackgroundColor,
            child: CalendarStrip(
              selectedDate: selectedDate,
              onDateSelected: (date) {
                setState(() {
                  _blockKeys.clear();
                  selectedDate = date;
                  _currentDateKey = DateFormat('yyyy-MM-dd').format(selectedDate);
                  _initStream();
                  _loadDayComplete();
                  _loadHistoricalData();
                  _calendarVisible = false;
                });
                final key = DateFormat('yyyy-MM-dd').format(selectedDate);
                final double? saved = _offsetCache[key];
                if (saved != null) {
                  _pendingScrollOffset = saved;
                } else {
                  _pendingScrollOffset = null;
                  WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
                }
              },
              completedDates: _loggedDates,
            ),
          ),
        ),
                  ],
                ),
              ),
              if (_aiProposals.isNotEmpty)
                Container(
                  color: Theme.of(context).primaryColor,
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  child: SafeArea(
                    top: false,
                    child: Row(
                      children: [
                        const Icon(Icons.auto_awesome, color: Colors.white),
                        const SizedBox(width: 12),
                        Expanded(
                          child: Text(
                            '${_aiProposals.length} suggestions pending',
                            style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
                          ),
                        ),
                        TextButton(
                          onPressed: () {
                            setState(() {
                              _aiProposals.clear();
                            });
                          },
                          style: TextButton.styleFrom(foregroundColor: Colors.white),
                          child: const Text('Discard'),
                        ),
                        const SizedBox(width: 8),
                        FilledButton(
                          onPressed: () async {
                            await _applyAllProposals();
                          },
                          style: FilledButton.styleFrom(
                            backgroundColor: Colors.white, 
                            foregroundColor: Theme.of(context).primaryColor,
                          ),
                          child: const Text('Apply All'),
                        ),
                      ],
                    ),
                  ),
                ),
            ],
          ),
        ), // Positioned.fill
      ], // Stack children
    ), // Stack
  ); // Scaffold
  }



  Future<void> _applyAllProposals() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;
    
    final batch = getFirestore().batch();
    final entriesColl = getFirestore().collection('timeline_entries').doc(uid).collection('entries');
    
    final existingMap = {
       for (var e in _cachedEntries) e.id: e
    };

    for (final entry in _aiProposals.entries) {
      final parts = entry.key.split(':'); // HH:mm
      final h = int.parse(parts[0]);
      final m = int.parse(parts[1]);
      final minute = m >= 30 ? 30 : 0;
      
      final start = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, h, minute);
      final id = _docId(start);
      final activity = entry.value.activity;

      if (existingMap.containsKey(id)) {
         batch.update(entriesColl.doc(id), {'planactivity': activity});
      } else {
         final newEntry = TimelineEntry(
          id: id,
          userId: uid,
          date: selectedDate,
          startTime: start,
          endTime: start.add(Duration(minutes: minute==0?60:30)),
          planactivity: activity,
          planNotes: '',
          activity: '',
          notes: '',
        );
        batch.set(entriesColl.doc(id), newEntry.toMap());
      }
    }

    try {
      await batch.commit();
      if (mounted) {
        setState(() {
          _aiProposals.clear();
        });
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('All pending changes applied.')));
      }
    } catch (e) {
      if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error applying changes: $e')));
    }
  }

  void _showDailyBriefing(BuildContext context) {
    // a bit hacky to clear the dot immediately on open, but good UX
    if (!_coachDismissed && _coachInsight != null) {
      setState(() {
        _coachDismissed = true;
      });
    }

    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent, // for rounded corners
      builder: (context) => Container(
        decoration: BoxDecoration(
          color: Theme.of(context).scaffoldBackgroundColor,
          borderRadius: const BorderRadius.vertical(top: Radius.circular(24)),
        ),
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Center(
              child: Container(
                width: 40, height: 4,
                margin: const EdgeInsets.only(bottom: 24),
                decoration: BoxDecoration(
                  color: Colors.grey.shade300,
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
            ),
            Row(
              children: [
                Icon(Icons.lightbulb, color: Colors.orange.shade700),
                const SizedBox(width: 12),
                const Text(
                  'Daily Briefing',
                  style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
                ),
              ],
            ),
            const SizedBox(height: 24),
            
            if (_coachInsight != null)
              CoachCard(
                insight: _coachInsight!,
                onDismiss: () => Navigator.pop(context), 
              )
            else 
              const Text("No specific insights for today. You're doing great!"),
              
            if (_morningBrief != null) ...[
               const SizedBox(height: 24),
               const Text('FROM YESTERDAY', style: TextStyle(fontWeight: FontWeight.bold, letterSpacing: 1.0, fontSize: 12, color: Colors.grey)),
               const SizedBox(height: 8),
               Container(
                 width: double.infinity,
                 padding: const EdgeInsets.all(16),
                 decoration: BoxDecoration(
                   color: Theme.of(context).primaryColor.withOpacity(0.05),
                   borderRadius: BorderRadius.circular(12),
                   border: Border.all(color: Theme.of(context).primaryColor.withOpacity(0.2)),
                 ),
                 child: Text(
                   _morningBrief!,
                   style: const TextStyle(fontSize: 14, height: 1.5),
                 ),
               ),
            ],

            const SizedBox(height: 32),
            SizedBox(
              width: double.infinity,
              child: FilledButton.icon(
                onPressed: () async {
                  Navigator.pop(context); // close sheet
                  final proposals = await DayPlanningAssistant.show(context, selectedDate, _cachedEntries, _activities);
                  if (proposals != null && proposals.isNotEmpty) {
                     if (mounted) setState(() => _aiProposals = proposals);
                  }
                  await _loadUserSettings();
                },
                icon: const Icon(Icons.auto_awesome),
                label: const Text('Generate AI Plan'),
                style: FilledButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
              ),
            ),
            const SizedBox(height: 32),
          ],
        ),
      ),
    );
  }

  Widget _buildTimelineStream(BuildContext context, AsyncSnapshot<QuerySnapshot> snapshot) {
    if (snapshot.hasError) {
      return SliverFillRemaining(child: Center(child: Text('Error: ${snapshot.error}')));
    }
    if (!snapshot.hasData) {
      return const SliverFillRemaining(child: Center(child: CircularProgressIndicator()));
    }
    var entries = snapshot.data?.docs
            .map((doc) => TimelineEntry.fromFirestore(doc))
            .toList() ?? [];

    // Local updates handling
    final bool onlyLocalUpdates = (snapshot.data != null &&
        snapshot.data!.docChanges.isNotEmpty &&
        snapshot.data!.docChanges.every((c) => c.doc.metadata.hasPendingWrites));

    if (onlyLocalUpdates) {
      for (final change in snapshot.data!.docChanges) {
        final updated = TimelineEntry.fromFirestore(change.doc);
        final idx = _cachedEntries.indexWhere((e) => e.id == updated.id);
        switch (change.type) {
          case DocumentChangeType.removed:
            if (idx != -1) _cachedEntries.removeAt(idx);
            break;
          case DocumentChangeType.modified:
          case DocumentChangeType.added:
            if (idx == -1) {
              _cachedEntries.add(updated);
            } else {
              _cachedEntries[idx] = updated;
            }
            break;
        }
      }
      entries = _cachedEntries;
    } else {
      _cachedEntries = entries;
    }

    _splitHours = entries
        .where((e) => e.startTime.minute == 30)
        .map((e) => e.startTime.hour)
        .toSet();

    _applyTemplateIfNeeded(entries);

    final DateTime today = DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day);
    final bool isPastDate = selectedDate.isBefore(today);
    if (!isPastDate && sleepTime != null && wakeTime != null) {
      for (var hour = 0; hour < 24; hour++) {
        if (_isSleepHour(hour)) {
          _ensureSleepEntry(hour, entries);
        }
      }
    }

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_pendingScrollOffset!=null && _scrollController.hasClients) {
        final max=_scrollController.position.maxScrollExtent;
        _scrollController.jumpTo(_pendingScrollOffset!.clamp(0,max));
        _pendingScrollOffset=null;
      }
    });

    return SliverToBoxAdapter(
      child: Column(
        children: List.generate(24, (index) {
          final hour = index;

          // Section titles (Morning/Afternoon/Evening)
          String? sectionTitle;
          if (wakeTime != null) {
            if (hour == wakeTime!.hour) sectionTitle = 'Morning';
          } else {
             if (hour == 6) sectionTitle = 'Morning';
          }
          if (hour == 12) sectionTitle = 'Afternoon';
          if (hour == 18) sectionTitle = 'Evening';

          Widget? sectionHeader;
          if (sectionTitle != null) {
             _sectionControllers.putIfAbsent(sectionTitle, () => TextEditingController(text: _sectionNotes[sectionTitle] ?? ''));
             final controller = _sectionControllers[sectionTitle]!;

             sectionHeader = Padding(
                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                child: Material(
                  color: Colors.transparent,
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [
                      Text(sectionTitle, style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Container(
                          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                          decoration: BoxDecoration(
                            color: Colors.grey.withOpacity(0.1),
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: TextField(
                            controller: controller,
                            onChanged: (val) => _onSectionNoteChanged(sectionTitle!, val),
                            decoration: const InputDecoration(
                              hintText: 'Add note...',
                              hintStyle: TextStyle(fontSize: 12, color: Colors.grey),
                              border: InputBorder.none,
                              isDense: true,
                            ),
                            style: Theme.of(context).textTheme.bodyMedium?.copyWith(fontSize: 12),
                            maxLines: 1,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
             );
          }

          TimelineEntry _blank(int minute) {
            final start=DateTime(selectedDate.year,selectedDate.month,selectedDate.day,hour,minute);
            return TimelineEntry(
              id: _docId(start),
              userId: FirebaseAuth.instance.currentUser?.uid ?? '',
              date: selectedDate,
              startTime: DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, minute),
              endTime: DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, minute).add(Duration(minutes: minute==0?60:30)),
              activity: '',
              notes: '',
            );
          }

          final entry00 = entries.firstWhere(
            (e) => e.startTime.hour == hour && e.startTime.minute == 0,
            orElse: () => _blank(0),
          );

          final entry30 = _splitHours.contains(hour)
              ? entries.firstWhere(
                  (e) => e.startTime.hour == hour && e.startTime.minute == 30,
                  orElse: () => _blank(30),
                )
              : null;
          
          final key00 = _blockKeys.putIfAbsent(_noteKey(hour, 0), () => GlobalKey());
          final key30 = _splitHours.contains(hour) 
              ? _blockKeys.putIfAbsent(_noteKey(hour, 30), () => GlobalKey())
              : null;

          return ValueListenableBuilder<TimelineViewMode>(
            valueListenable: _viewModeNotifier,
            builder: (context, viewMode, _) {
            final bool hasProposal30 = _aiProposals.containsKey(_noteKey(hour, 30));
            final bool isSplit = _splitHours.contains(hour) || hasProposal30;
            
            Widget tileContent;



            if (!isSplit) {
              tileContent = TimelineHourTile(
                key: ValueKey(hour),
                hour: hour,
                entry00: entry00,
                entry30: entry30,
                isSplit: _splitHours.contains(hour),
                viewMode: viewMode,
                onToggleSplit: () => _toggleSplit(hour),
                onUpdateEntry: _updateEntry,
                availableActivities: _flattenCats(),
                historyActivities: _getSuggestionsForHour(hour),
                recentActivitiesNotifier: _recentActivitiesNotifier,
                onPromptCustomActivity: () => _promptCustomActivity(context),
                onUpdateRecentActivity: (act) {
                    bool changed = false;
                    // If it's already in the list, remove it so we can push it to the top
                    if (_recentActivities.contains(act)) {
                       // Only mark changed if it wasn't already at the top
                       if (_recentActivities.indexOf(act) != 0) {
                         _recentActivities.remove(act);
                         _recentActivities.insert(0, act);
                         changed = true;
                       }
                    } else {
                       // New addition
                       _recentActivities.insert(0, act);
                       if (_recentActivities.length > 8) _recentActivities.removeLast();
                       changed = true;
                    }

                    if (!_activities.contains(act) && !_archivedActivities.contains(act)) {
                       _activities.add(act);
                       _dedupCats(); 
                       changed = true;
                    }
                    if (changed) {
                      _recentActivitiesNotifier.value = List.from(_recentActivities);
                      _saveSettings(refreshTimeline: false, showConfirmation: false);
                    }
                },
                key00: key00,
                key30: key30,
                proposedActivity00: _aiProposals[_noteKey(hour, 0)]?.activity,
                proposedActivity30: _aiProposals[_noteKey(hour, 30)]?.activity,
                proposedReason00: _aiProposals[_noteKey(hour, 0)]?.reason,
                proposedReason30: _aiProposals[_noteKey(hour, 30)]?.reason,
                onAcceptProposal: (entry, activity) {
                   setState(() {
                     _aiProposals.remove(_noteKey(entry.startTime.hour, entry.startTime.minute));
                   });
                   _updateEntry(entry, activity, entry.planNotes, isPlan: true);
                },
                onRejectProposal: (entry) {
                   setState(() {
                     _aiProposals.remove(_noteKey(entry.startTime.hour, entry.startTime.minute));
                   });
                },
              );
            } else {
              // This is a tricky one. The previous replace might have context issues.
              // I will use a larger block or simply match the existing call.
              tileContent = TimelineHourTile(
                key: ValueKey(hour),
                hour: hour,
                entry00: entry00,
                entry30: entry30,
                isSplit: _splitHours.contains(hour),
                viewMode: viewMode,
                onToggleSplit: () => _toggleSplit(hour),
                onUpdateEntry: _updateEntry,
                availableActivities: _flattenCats(),
                historyActivities: _getSuggestionsForHour(hour),
                recentActivitiesNotifier: _recentActivitiesNotifier,
                onPromptCustomActivity: () => _promptCustomActivity(context),
                onUpdateRecentActivity: (act) {
                    bool changed = false;
                    if (_recentActivities.contains(act)) {
                       if (_recentActivities.indexOf(act) != 0) {
                         _recentActivities.remove(act);
                         _recentActivities.insert(0, act);
                         changed = true;
                       }
                    } else {
                       _recentActivities.insert(0, act);
                       if (_recentActivities.length > 8) _recentActivities.removeLast();
                       changed = true;
                    }

                    if (!_activities.contains(act) && !_archivedActivities.contains(act)) {
                       _activities.add(act);
                       _dedupCats(); 
                       changed = true;
                    }
                    if (changed) {
                      _recentActivitiesNotifier.value = List.from(_recentActivities);
                      _saveSettings(refreshTimeline: false, showConfirmation: false);
                    }
                },
                key00: key00,
                key30: key30,
                proposedActivity00: _aiProposals[_noteKey(hour, 0)]?.activity,
                proposedActivity30: _aiProposals[_noteKey(hour, 30)]?.activity,
                proposedReason00: _aiProposals[_noteKey(hour, 0)]?.reason,
                proposedReason30: _aiProposals[_noteKey(hour, 30)]?.reason,
                onAcceptProposal: (entry, activity) {
                   setState(() {
                     _aiProposals.remove(_noteKey(entry.startTime.hour, entry.startTime.minute));
                   });
                   _updateEntry(entry, activity, entry.planNotes, isPlan: true);
                },
                onRejectProposal: (entry) {
                   setState(() {
                     _aiProposals.remove(_noteKey(entry.startTime.hour, entry.startTime.minute));
                   });
                },
              );
            }

            if (sectionTitle != null) {
              return Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  if (sectionHeader != null) sectionHeader,
                  tileContent,
                ],
              );
            }
            return tileContent;
          });
        }),
      ),
    );
  }



  Future<void> _updateEntry(TimelineEntry entry, String activity, String notes, {bool isPlan=false}) async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      final entriesColl = getFirestore()
          .collection('timeline_entries')
          .doc(user.uid)
          .collection('entries');

      final docId = _docId(entry.startTime);

      // Calculate strict end time to prevent overlaps
      DateTime newEndTime;
      if (_splitHours.contains(entry.startTime.hour)) {
        // Split hour: strictly 30 minutes
        newEndTime = entry.startTime.add(const Duration(minutes: 30));
      } else {
        // Full hour: strictly 60 minutes
        newEndTime = entry.startTime.add(const Duration(hours: 1));
      }

      final fullEntry = TimelineEntry(
        id: docId,
        userId: user.uid,
        date: entry.date,
        startTime: entry.startTime,
        endTime: newEndTime,
        planactivity: isPlan ? activity : entry.planactivity,
        planNotes: isPlan ? notes : entry.planNotes,
        activity: isPlan ? entry.activity : activity,
        notes: isPlan ? entry.notes : notes,
      );

      await entriesColl.doc(docId).set(fullEntry.toMap());
    } catch (e) {
      final messenger = ScaffoldMessenger.maybeOf(context);
      messenger?.showSnackBar(
        const SnackBar(content: Text('Unable to update entry. Please try again later.')),
      );
    }

    // Update lastPlannedAt if this is a new plan
    if (isPlan && activity.isNotEmpty && _lastPlannedAt == null) {
      final now = DateTime.now();
      // Only set if we are planning for today or future (or even yesterday if just doing it now)
      // The logic is: "When did they make the plan?" -> Now.
      try {
        final user = FirebaseAuth.instance.currentUser;
        if (user != null) {
          await getFirestore()
              .collection('daily_logs')
              .doc(user.uid)
              .collection('logs')
              .doc(_dateStr(entry.date))
              .set({'lastPlannedAt': FieldValue.serverTimestamp()}, SetOptions(merge: true));
          
          if (mounted) setState(() => _lastPlannedAt = now);
        }
      } catch (_) {}
    }
  }



  // _showActivitiesDialog removed. Use ActivitiesManagementScreen instead.

  Future<void> _saveSettings({bool refreshTimeline = true, bool showConfirmation = true}) async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      final settingsRef = getFirestore()
          .collection('user_settings')
          .doc(user.uid);

      _dedupCats();

      // Determine if times actually changed (compare by hour/minute not string)
      TimeOfDay _toTod(String s) => _parseTime(s);

      final prevSleep = sleepTime ?? _toTod(_sleepTimeController.text);
      final prevWake = wakeTime ?? _toTod(_wakeTimeController.text);
      final newSleep = _toTod(_sleepTimeController.text);
      final newWake = _toTod(_wakeTimeController.text);
      final bool timesChanged = prevSleep != newSleep || prevWake != newWake;

      // Persist only activities that are not part of the built-in defaults
      final Set<String> defaultSet = Set.of(kDefaultActivities);
      final List<String> customOnly = _activities.where((a) => !defaultSet.contains(a)).toList();

      await settingsRef.set({
        'sleepTime': _sleepTimeController.text,
        'wakeTime': _wakeTimeController.text,
        'customActivities': customOnly,
        'archivedActivities': _archivedActivities,
        'subActivities': _subActivities,
        'recentActivities': _recentActivities,
        'lastUpdated': FieldValue.serverTimestamp(),
      }, SetOptions(merge: true));

      // refresh local vars
      if (refreshTimeline && mounted) {
        setState(() {
          if (timesChanged) {
            sleepTime = newSleep;
            wakeTime = newWake;
          }
          // ensure Activities list refreshes in timeline & dropdown
          _activities = List<String>.from(_activities);
        });
      }

      if (timesChanged) {
        await _reconcileSleepEntriesForSelectedDate();
      }

      if (showConfirmation) {
        ScaffoldMessenger.maybeOf(context)?.showSnackBar(
          const SnackBar(content: Text('Settings saved')),
        );
      }
    } catch (e) {
      if (showConfirmation) {
        ScaffoldMessenger.maybeOf(context)?.showSnackBar(
          const SnackBar(content: Text('Unable to save settings. Please try again later.')),
        );
      }
    }
  }

  String _fmt24(TimeOfDay t) => '${t.hour.toString().padLeft(2, '0')}:${t.minute.toString().padLeft(2, '0')}';

  void _initStream() {
    _currentStream = getFirestore()
          .collection('timeline_entries')
          .doc(FirebaseAuth.instance.currentUser?.uid ?? '')
          .collection('entries')
          .where('date', isEqualTo: DateFormat('yyyy-MM-dd').format(selectedDate))
          .snapshots();
  }

  void _dedupCats() {
    _activities = _activities.toSet().toList();
    _archivedActivities = _archivedActivities.toSet().toList();
  }

  Future<void> _toggleSplit(int hour) async {
    final userId = FirebaseAuth.instance.currentUser?.uid;
    if (userId == null) return;
    
    final entriesColl = getFirestore()
        .collection('timeline_entries')
        .doc(userId)
        .collection('entries');

    final fullStart = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, 0);
    final fullDocId = _docId(fullStart);
    final halfStart = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, 30);
    final halfDocId = _docId(halfStart);

    final batch = getFirestore().batch();

    if (_splitHours.contains(hour)) {
      // MERGE -> remove 30-minute entry AND extend 00-entry to full hour
      batch.delete(entriesColl.doc(halfDocId));
      batch.update(entriesColl.doc(fullDocId), {
        'endTime': Timestamp.fromDate(fullStart.add(const Duration(hours: 1)))
      });

      _splitHours.remove(hour);
      _cachedEntries.removeWhere((e) => e.id == halfDocId);
      
      // Update local cache for 00 entry
      final idx = _cachedEntries.indexWhere((e) => e.id == fullDocId);
      if (idx != -1) {
        final old = _cachedEntries[idx];
        _cachedEntries[idx] = TimelineEntry(
          id: old.id, userId: old.userId, date: old.date, startTime: old.startTime,
          endTime: old.startTime.add(const Duration(hours: 1)),
          activity: old.activity, notes: old.notes,
          planactivity: old.planactivity, planNotes: old.planNotes
        );
      }

    } else {
      // SPLIT -> add 30-minute entry AND shrink 00-entry to 30 mins
      
      // 1. Fetch 00 entry to potentially copy data
      final idx00 = _cachedEntries.indexWhere((e) => e.id == fullDocId);
      String existingActivity = '';
      String existingPlanActivity = '';
      String existingPlanNotes = '';
      
      if (idx00 != -1) {
          existingActivity = _cachedEntries[idx00].activity;
          existingPlanActivity = _cachedEntries[idx00].planactivity;
          existingPlanNotes = _cachedEntries[idx00].planNotes;
      }
      
      // 2. Create 30-min entry (Auto-fill with existing values)
      final newEntry = TimelineEntry(
        id: halfDocId,
        userId: userId,
        date: selectedDate,
        startTime: halfStart,
        endTime: halfStart.add(const Duration(minutes: 30)),
        activity: existingActivity, // Auto-fill actual
        notes: '',
        planactivity: existingPlanActivity, // Auto-fill plan
        planNotes: existingPlanNotes,
      );
      batch.set(entriesColl.doc(halfDocId), newEntry.toMap());

      // 2. Shrink 00-min entry
      // We must ensure 00-entry exists. If it doesn't (visual blank), we should create it.
      // But _blank() is visual only. 
      // The user clicked "split", implies they want to edit.
      // If 00 doesn't exist in DB, we should create it now.
      
      final idx = _cachedEntries.indexWhere((e) => e.id == fullDocId);
      if (idx == -1) {
        // Create 00 entry as well
        final entry00 = TimelineEntry(
          id: fullDocId,
          userId: userId,
          date: selectedDate,
          startTime: fullStart,
          endTime: fullStart.add(const Duration(minutes: 30)), // shrink immediately
          activity: '',
          notes: '',
        );
        batch.set(entriesColl.doc(fullDocId), entry00.toMap());
        _cachedEntries.add(entry00);
      } else {
        // Update existing
        batch.update(entriesColl.doc(fullDocId), {
          'endTime': Timestamp.fromDate(fullStart.add(const Duration(minutes: 30)))
        });
        final old = _cachedEntries[idx];
        _cachedEntries[idx] = TimelineEntry(
          id: old.id, userId: old.userId, date: old.date, startTime: old.startTime,
          endTime: old.startTime.add(const Duration(minutes: 30)),
          activity: old.activity, notes: old.notes,
          planactivity: old.planactivity, planNotes: old.planNotes
        );
      }

      _splitHours.add(hour);
      _cachedEntries.add(newEntry);
    }

    await batch.commit();

  }

  String _noteKey(int hour, int minute) => '${hour.toString().padLeft(2,'0')}:${minute.toString().padLeft(2,'0')}';

  String _dateStr(DateTime d)=>DateFormat('yyyy-MM-dd').format(d);

  Future<void> _loadDayComplete() async{
    final uid=FirebaseAuth.instance.currentUser?.uid; if(uid==null) return;
    final doc=await getFirestore().collection('daily_logs').doc(uid).collection('logs').doc(_dateStr(selectedDate)).get();
    if (doc.exists && doc.data() != null) {
      _dayCompleteNotifier.value = doc.data()!['complete'] == true;
      if (doc.data()!.containsKey('lastPlannedAt')) {
        _lastPlannedAt = (doc.data()!['lastPlannedAt'] as Timestamp).toDate();
      } else {
        _lastPlannedAt = null;
      }


      if (doc.data()!.containsKey('scoreDetails')) {
        try {
          // Add doc ID if needed, or just map
          // We need userId and date to reconstruct if not fully in map, but fromFirestore handles it usually?
          // DailyScore.fromFirestore expects a DocSnapshot. We have a map here if it's a field.
          // Let's modify DailyScore to have fromMap or just manual parse.
          // Accessing 'scoreDetails' map:
          final sMap = doc.data()!['scoreDetails'] as Map<String, dynamic>;
          // Reconstruct DailyScore from map
          _dailyScore = DailyScore(
            userId: sMap['userId'],
            date: (sMap['date'] as Timestamp).toDate(),
            totalScore: sMap['totalScore'],
            breakdown: Map<String, int>.from(sMap['breakdown'] ?? {}),
            aiGoalAnalysis: sMap['aiGoalAnalysis'] ?? '',
            coachTip: sMap['coachTip'] ?? '',
            computedAt: (sMap['computedAt'] as Timestamp).toDate(),
          );
        } catch (_) {
          _dailyScore = null;
        }
      } else {
        _dailyScore = null;
      }
      
      if (doc.data()!.containsKey('sectionNotes')) {
         final sn = doc.data()!['sectionNotes'] as Map<String, dynamic>;
         _sectionNotes = sn.map((k, v) => MapEntry(k, v.toString()));
      } else {
        _sectionNotes = {};
      }
      
      // Sync controllers
      // We only recreate/update controllers if they are not currently being edited?
      // Actually simpler: just update text if different to avoid cursor jumps if user typing (cached logic)
      // modifying state here is fine as we are in _loadDayComplete
      for (var key in ['Morning', 'Afternoon', 'Evening']) {
         final txt = _sectionNotes[key] ?? '';
         if (!_sectionControllers.containsKey(key)) {
            _sectionControllers[key] = TextEditingController(text: txt);
         } else {
            if (_sectionControllers[key]!.text != txt) {
               // Only update if not focused? Or rely on debouncer not firing yet?
               // If this load happens while user is typing (e.g. background refresh), it might clobber.
               // But _loadDayComplete usually happens on day switch or explicit refresh.
               _sectionControllers[key]!.text = txt;
            }
         }
      }

    } else {
      _dayCompleteNotifier.value = false;
      _lastPlannedAt = null;
      _dailyScore = null;
      _sectionNotes = {};
      for (var c in _sectionControllers.values) c.clear();
    }
    if (mounted) setState(() {});
  }

  Future<void> _calculateAndShowScore() async {
    if (_isCalculatingScore) return;
    if (_dailyScore != null) {
      DayScoreDialog.show(context, _dailyScore!, onRecalculate: () {
        setState(() => _dailyScore = null); // Clear cache
        _calculateAndShowScore(); // Re-run
      });
      return;
    }
    
    setState(() => _isCalculatingScore = true);
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;
      
      // 1. Get UserSettings
      final settingsDoc = await getFirestore().collection('user_settings').doc(user.uid).get();
      final settings = settingsDoc.exists 
        ? UserSettings.fromMap(settingsDoc.data()!) 
        : UserSettings(userId: user.uid, sleepTime: TimeOfDay(hour: 23, minute: 0), wakeTime: TimeOfDay(hour: 7, minute: 0));

      // 2. Prepare DailyLog object
      final dailyLog = DailyLog(
        dateStr: _dateStr(selectedDate), 
        complete: _dayComplete, 
        lastUpdated: DateTime.now(),
        lastPlannedAt: _lastPlannedAt,
      );

      // 3. Calculate
      final newScore = await ScoreService().calculateDailyScore(
        userId: user.uid,
        date: selectedDate,
        entries: _cachedEntries, // Use cached entries for current view
        log: dailyLog,
        settings: settings,
      );

      // 4. Save
      await getFirestore()
          .collection('daily_logs')
          .doc(user.uid)
          .collection('logs')
          .doc(_dateStr(selectedDate))
          .set({'scoreDetails': newScore.toMap()}, SetOptions(merge: true));

      if (mounted) {
        setState(() {
          _dailyScore = newScore;
          _isCalculatingScore = false;
        });
        DayScoreDialog.show(context, newScore);
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isCalculatingScore = false);
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error calculating score: $e')));
      }
    }
  }



  Future<void> _setDayComplete(bool val) async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;

    // Optimistically update UI immediately
    _dayCompleteNotifier.value = val;

    final ref = getFirestore()
        .collection('daily_logs')
        .doc(uid)
        .collection('logs')
        .doc(_dateStr(selectedDate));

    try {
      if (val) {
        await ref.set({
          'date': _dateStr(selectedDate),
          'complete': true,
          'lastUpdated': FieldValue.serverTimestamp(),
        });
        _loggedDates.add(_dateStr(selectedDate));
        // Trigger generic overview if not present
            // Trigger new score calc if not present?
            // Actually _calculateAndShowScore handles it manually via button.
            // We shouldn't auto-trigger the OLD one.
            // if (_dailyScore == null) _calculateAndShowScore(); // Optional: Auto-trigger new score?
            // User requested manual trigger usually. Let's just remove the old call.
      } else {
        await ref.delete();
        _loggedDates.remove(_dateStr(selectedDate));
      }
    } catch (e) {
      // Revert on failure and inform user
      _dayCompleteNotifier.value = !val;
      ScaffoldMessenger.maybeOf(context)?.showSnackBar(
        const SnackBar(content: Text('Could not update day status. Please try again.')),
      );
    }
  }

  // ---------- Sub-activity helpers ----------
  Future<void> _addSubactivity(String parent, String sub) async {
    if (sub.trim().isEmpty) return;
    if (!_activities.contains(parent)) {
      _activities.add(parent);
    }
    final list = _subActivities[parent] ?? <String>[];
    if (!list.contains(sub)) {
      list.add(sub);
      _subActivities[parent] = list;
      await _saveSettings(refreshTimeline: true);

      final double offset=_scrollController.hasClients?_scrollController.offset:0;
      if (mounted) setState(() {});
      WidgetsBinding.instance.addPostFrameCallback((_){
        if(_scrollController.hasClients){
          _scrollController.jumpTo(offset.clamp(0,_scrollController.position.maxScrollExtent));
        }
      });
    }
  }

  Future<void> _removeSubactivity(String parent, String sub) async {
    final list = _subActivities[parent];
    if (list == null) return;
    list.remove(sub);
    if (list.isEmpty) {
      _subActivities.remove(parent);
    } else {
      _subActivities[parent] = list;
    }
    await _saveSettings(refreshTimeline: true);
    final double offset=_scrollController.hasClients?_scrollController.offset:0;
    if (mounted) setState(() {});
    WidgetsBinding.instance.addPostFrameCallback((_){
      if(_scrollController.hasClients){
        _scrollController.jumpTo(offset.clamp(0,_scrollController.position.maxScrollExtent));
      }
    });
  }

  Future<void> _applyTemplateIfNeeded(List<TimelineEntry> currentEntries) async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;
    // Only today or future
    final DateTime today = DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day);
    if (selectedDate.isBefore(today)) return;
    if (_dayComplete) return; // don't overwrite completed day

    // Check if template was already applied today (or user manually cleared it, setting this flag)
    final dailyLogRef = getFirestore().collection('daily_logs').doc(uid).collection('logs').doc(_dateStr(selectedDate));
    final dailyLogSnap = await dailyLogRef.get();
    
    if (dailyLogSnap.exists) {
       final data = dailyLogSnap.data();
       if (data != null && data['templateApplied'] == true) {
         return; // Already applied or supressed
       }
    }

    QuerySnapshot tmplSnap;

    // Fetch user templates matches
    final tmplQuery = await getFirestore()
        .collection('user_templates')
        .doc(uid)
        .collection('templates')
        .where('daysOfWeek', arrayContains: selectedDate.weekday)
        .get();

    if (tmplQuery.docs.isNotEmpty) {
      // Use the first matching template
      final tmplDocSnapshot = tmplQuery.docs.first;
      final tmplId = tmplDocSnapshot.id;
      final tmplData = tmplDocSnapshot.data() as Map<String, dynamic>;
      
      // Check validUntil
      if (tmplData.containsKey('validUntil') && tmplData['validUntil'] != null) {
        final validUntilTimestamp = tmplData['validUntil'] as Timestamp;
        final validUntilDate = validUntilTimestamp.toDate();
        // Compare dates (ignoring time)
        final vDate = DateTime(validUntilDate.year, validUntilDate.month, validUntilDate.day);
        final sDate = DateTime(selectedDate.year, selectedDate.month, selectedDate.day);
        
        if (sDate.isAfter(vDate)) {
           // Template is expired for this date
           return;
        }
      }

      tmplSnap = await getFirestore()
          .collection('user_templates')
          .doc(uid)
          .collection('templates')
          .doc(tmplId)
          .collection('entries')
          .get();
    } else {
      // Try to fallback to "Default" or legacy if no specific day match?
      // Actually, if we migrated everything to "Default" (days 1-7), the above query should catch it if they didn't change it.
      // But if they created a specific one and removed days from default, we might have gaps.
      // If no template matches this day, we do nothing.
      
      // However, check for LEGACY (pre-migration) just in case user didn't open templates screen yet
      final legacyColl = getFirestore().collection('template_entries').doc(uid).collection('entries');
      tmplSnap = await legacyColl.get();
      if (tmplSnap.docs.isEmpty) return; // No legacy either
    }

    if (tmplSnap.docs.isEmpty) {
      return; // no template entries found in the matching template
    }

    final Map<String, TimelineEntry> existingMap = {
      for (var e in currentEntries) _noteKey(e.startTime.hour, e.startTime.minute): e
    };

    final batch = getFirestore().batch();
    final entriesColl = getFirestore().collection('timeline_entries').doc(uid).collection('entries');

    bool appliedAny = false;

    for (final doc in tmplSnap.docs) {
      final hour = int.parse(doc.id.substring(0, 2));
      final minute = int.parse(doc.id.substring(2));
      final key = _noteKey(hour, minute);
      final data = doc.data() as Map<String, dynamic>; // Safely cast
      final tmplPlanCat = data['planactivity'] ?? data['activity'] ?? '';
      final tmplPlanNotes = data['planNotes'] ?? data['notes'] ?? '';
      final tmplRetroCat = (data['activity'] ?? '') == 'Sleep' ? 'Sleep' : '';
      final tmplRetroNotes = tmplRetroCat.isNotEmpty ? (data['notes'] ?? '') : '';

      if (existingMap.containsKey(key)) {
        final existing = existingMap[key]!;
        final Map<String,dynamic> upd={};
        if(existing.planactivity.isEmpty){
          upd['planactivity']=tmplPlanCat; upd['planNotes']=tmplPlanNotes; }
        if(tmplRetroCat.isNotEmpty && existing.activity.isEmpty){
          upd['activity']=tmplRetroCat; upd['notes']=tmplRetroNotes; }
        if(upd.isNotEmpty){
           batch.update(entriesColl.doc(existing.id),upd);
           appliedAny = true;
        }        
        continue;
      }

      // If document doesn't exist, created it
      final start = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, minute);
      final newEntry = TimelineEntry(
        id: _docId(start),
        userId: uid,
        date: selectedDate,
        startTime: start,
        endTime: start.add(Duration(minutes: minute == 0 ? 60 : 30)),
        planactivity: tmplPlanCat,
        planNotes: tmplPlanNotes,
        activity: tmplRetroCat,
        notes: tmplRetroNotes,
      );
      batch.set(entriesColl.doc(newEntry.id), newEntry.toMap());
      appliedAny = true;
    }
    
    // Mark as applied so we don't re-apply on refresh
    if (appliedAny || tmplSnap.docs.isNotEmpty) {
      batch.set(dailyLogRef, {'templateApplied': true}, SetOptions(merge: true));
    }

    await batch.commit();
  }

  List<String> _flattenCats() {
    final flatSet = <String>{};
    void addParent(String parent) {
      flatSet.add(parent);
      final subs = _subActivities[parent] ?? [];
      for (final s in subs) {
        flatSet.add('$parent / $s');
      }
    }

    for (final parent in _activities) {
      addParent(parent);
    }

    final DateTime today = DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day);
    if (selectedDate.isBefore(today)) {
      for (final parent in _archivedActivities) {
        addParent(parent);
      }
    }

    return flatSet.toList();
  }

  Future<String?> _promptCustomActivity(BuildContext context) async {
    final TextEditingController ctrl = TextEditingController();
    return showDialog<String>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Custom activity'),
        content: TextField(
          controller: ctrl,
          autofocus: true,
          decoration: const InputDecoration(hintText: 'Enter activity'),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),
          TextButton(onPressed: () => Navigator.pop(ctx, ctrl.text.trim()), child: const Text('OK')),
        ],
      ),
    );
  }

  void _updateRecent(String act) {
    _recentActivities.remove(act);
    _recentActivities.insert(0, act);
    if (_recentActivities.length > 8) {
      _recentActivities = _recentActivities.sublist(0, 8);
    }
    final user = FirebaseAuth.instance.currentUser;
    if (user != null) {
      getFirestore()
          .collection('user_settings')
          .doc(user.uid)
          .set({'recentActivities': _recentActivities}, SetOptions(merge: true));
    }
  }

  Future<void> _loadLoggedDates() async {
    final uid=FirebaseAuth.instance.currentUser?.uid; if(uid==null) return;
    final today=DateTime.now();
    final start=today.subtract(const Duration(days:7));
    final end=today.add(const Duration(days:7));
    final snap=await getFirestore().collection('daily_logs').doc(uid).collection('logs')
      .where('date', isGreaterThanOrEqualTo: DateFormat('yyyy-MM-dd').format(start))
      .where('date', isLessThanOrEqualTo: DateFormat('yyyy-MM-dd').format(end))
      .get();
    _loggedDates = snap.docs.map((d)=>d.id).toSet();
    if(mounted) setState((){});
  }

  Future<void> _clearTimeline({required bool keepSleep}) async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;
    if (_dayComplete) {
       ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Cannot clear completed day')));
       return;
    }

    final batch = getFirestore().batch();
    final entriesColl = getFirestore().collection('timeline_entries').doc(uid).collection('entries');

    bool hasChanges = false;
    for (final entry in _cachedEntries) {
      bool shouldClear = true;
      if (keepSleep && entry.activity == 'Sleep') {
        shouldClear = false;
      }
      
      // If we are clearing, we reset to empty strings.
      // If keeping sleep, we preserve it. 
      // Note: "Clear" usually means resetting to blank state. 
      // If split hours exist, we might want to merge them back? 
      // For now, let's just clear the content but keep structure to be safe, or we can just update fields.
      
      if (shouldClear) {
        // If it was already empty, no need to write, but to be safe check
        if (entry.activity.isNotEmpty || entry.notes.isNotEmpty || entry.planactivity.isNotEmpty || entry.planNotes.isNotEmpty) {
           batch.update(entriesColl.doc(entry.id), {
             'activity': '',
             'notes': '',
             'planactivity': '',
             'planNotes': '',
           });
           hasChanges = true;
        }
      } else {
        // Keeping Sleep -> Ensure plan matches actual if we want? 
        // User said "Clear except sleep". 
        // If I have Plan: Gym, Actual: Sleep -> Keep Activity:Sleep. Plan: Gym? 
        // Usually "Clear" implies clearing the slate. So likely we want to clear Plan too?
        // Let's assume we clear Plan unless it matches preserved Activity.
        // Actually simplest interpretation: "Clear everything, but if Activity is Sleep, leave that Activity/Note alone."
        // What about Plan? 
        
        // If the goal is "I want to clear everything except sleep and make changes", 
        // likely they want to re-plan the day. So if I planned Gym but Slept, and I keep Sleep, 
        // I probably want to clear the "Gym" plan.
        
        // So for the "Sleep" entry:
        // Do we clear its Plan? 
        // If I have Plan: Sleep, Actual: Sleep -> Keep both.
        // If I have Plan: Work, Actual: Sleep -> Keep Actual:Sleep. Clear Plan? 
        // Let's clear Plan for consistency, unless implementation detail says otherwise.
        // But the prompt says "clear already filled values except sleep time".
        
        // I will clear Plan fields even for Sleep entries if they differ? 
        // Let's just update the NON-sleep fields.
        // Actually, if we keep sleep, we probably want to keep the entry as is.
        // But if there is a plan attached that isn't sleep...
        // Let's safe side: Touch NOTHING on a Sleep entry.
      }
    }

    if (hasChanges) {
      // Also ensure we don't re-apply template
      final dailyLogRef = getFirestore()
          .collection('daily_logs')
          .doc(uid)
          .collection('logs')
          .doc(_dateStr(selectedDate));
      
      batch.set(dailyLogRef, {'templateApplied': true}, SetOptions(merge: true));

      await batch.commit();
      // Optimistic update handled by listener usually, but we can verify
    }
  }

  void _onSectionNoteChanged(String section, String val) {
    _sectionNotes[section] = val; // Update local state immediately for UI consistency
    
    _sectionDebouncers[section]?.cancel();
    _sectionDebouncers[section] = Timer(const Duration(milliseconds: 1000), () async {
       final uid = FirebaseAuth.instance.currentUser?.uid;
       if (uid != null) {
          // Clean up empty notes to save space? Or keep empty string?
          if (val.isEmpty) {
             _sectionNotes.remove(section);
          }
          
          await getFirestore()
              .collection('daily_logs')
              .doc(uid)
              .collection('logs')
              .doc(_dateStr(selectedDate))
              .set({'sectionNotes': _sectionNotes}, SetOptions(merge: true));
       }
    });
  }
}