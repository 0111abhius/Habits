import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../models/timeline_entry.dart';
import '../widgets/calendar_strip.dart';
import '../widgets/habit_tracker.dart';
import '../main.dart';  // Import for getFirestore()
import 'package:intl/intl.dart';
import 'dart:async';
import '../utils/categories.dart';

class TimelineScreen extends StatefulWidget {
  const TimelineScreen({super.key});

  @override
  State<TimelineScreen> createState() => _TimelineScreenState();
}

class _TimelineScreenState extends State<TimelineScreen> {
  DateTime selectedDate = DateTime.now();
  static const List<String> _protectedCategories = ['Sleep'];
  List<String> _categories = List.from(kDefaultCategories);

  String _displayLabel(String cat) => displayCategory(cat);

  List<String> _archivedCategories = []; // categories removed from active but kept for history
  Map<String, List<String>> _subCategories = {}; // parent -> list of subs

  TimeOfDay? wakeTime;
  TimeOfDay? sleepTime;
  late final ScrollController _scrollController;
  final TextEditingController _sleepTimeController = TextEditingController();
  final TextEditingController _wakeTimeController = TextEditingController();

  final Map<String, TextEditingController> _noteControllers = {};
  final Map<String, Timer> _noteDebouncers = {};
  double? _pendingScrollOffset;

  Set<int> _splitHours = {}; // hours that have a 30-minute split for the selected date
  // Cache of the most recently rendered entries list. This lets us re-use the
  // previous UI when the only Firestore changes are still pending writes
  // generated by this device – preventing a visible full list refresh.
  List<TimelineEntry> _cachedEntries = [];

  final ValueNotifier<bool> _habitsExpandedNotifier = ValueNotifier(true);
  final ValueNotifier<bool> _showRetroNotifier = ValueNotifier(false);

  bool get _habitsExpanded => _habitsExpandedNotifier.value;

  Color _planBg(BuildContext context) => Color.alphaBlend(Colors.indigo.withOpacity(0.04), Theme.of(context).colorScheme.surface);
  Color _retroBg(BuildContext context) => Color.alphaBlend(Colors.orange.withOpacity(0.04), Theme.of(context).colorScheme.surface);

  // Using a ValueNotifier means toggling the "Day fully logged" checkbox
  // only rebuilds that specific part of the UI instead of the whole timeline.
  final ValueNotifier<bool> _dayCompleteNotifier = ValueNotifier(false);

  // Convenience getter so existing read-access sites keep working.
  bool get _dayComplete => _dayCompleteNotifier.value;

  bool get _showRetro => _showRetroNotifier.value;

  final Map<String, GlobalKey> _blockKeys = {};

  static final Map<String, double> _offsetCache = {}; // keyed by yyyy-MM-dd (selected date)
  late String _currentDateKey;

  @override
  void initState() {
    super.initState();
    _currentDateKey = DateFormat('yyyy-MM-dd').format(selectedDate);
    _scrollController = ScrollController(initialScrollOffset: _offsetCache[_currentDateKey] ?? 0)
      ..addListener(() {
        _offsetCache[_currentDateKey] = _scrollController.offset;
      });
    _loadUserSettings();
    _loadDayComplete();
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _sleepTimeController.dispose();
    _wakeTimeController.dispose();

    for (final c in _noteControllers.values) {
      c.dispose();
    }
    for (final t in _noteDebouncers.values) {
      t.cancel();
    }
    _noteDebouncers.values.forEach((t) => t.cancel());
    _pendingScrollOffset=null;
    super.dispose();
  }

  // Helper to parse 'HH:mm' strings to TimeOfDay
  TimeOfDay _parseTime(String s) {
    final parts = s.split(':');
    return TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1]));
  }

  Future<void> _reconcileSleepEntriesForSelectedDate() async {
    if (sleepTime == null || wakeTime == null) return;
    // Do not modify historical data: only reconcile for today or future
    final DateTime today = DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day);
    if (selectedDate.isBefore(today)) return;
    final userId = FirebaseAuth.instance.currentUser?.uid;
    if (userId == null) return;

    final entriesColl = getFirestore()
        .collection('timeline_entries')
        .doc(userId)
        .collection('entries');

    final dateStr = DateFormat('yyyy-MM-dd').format(selectedDate);
    final snapshot = await entriesColl.where('date', isEqualTo: dateStr).get();
    final entries = snapshot.docs.map((d) => TimelineEntry.fromFirestore(d)).toList();

    for (var hour = 0; hour < 24; hour++) {
      final shouldSleep = _isSleepHour(hour);
      final matching = entries.where((e) => e.startTime.hour == hour);
      final TimelineEntry? existing = matching.isNotEmpty ? matching.first : null;

      final start = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour);
      final id = _docId(start);

      if (shouldSleep) {
        // ensure a placeholder exists but DO NOT override if user already set another category
        if (existing == null) {
          final newEntry = TimelineEntry(
            id: id,
            userId: userId,
            date: selectedDate,
            startTime: start,
            endTime: start.add(const Duration(hours: 1)),
            category: 'Sleep',
            notes: '',
          );
          await entriesColl.doc(id).set(newEntry.toMap(), SetOptions(merge: true));
        } else if (existing.category.isEmpty) {
          // only auto-fill if user hasn't picked something yet
          await entriesColl.doc(existing.id).update({'category': 'Sleep'});
        }
      } else {
        // should NOT be sleep
        if (existing != null && existing.category == 'Sleep') {
          await entriesColl.doc(existing.id).update({'category': ''});
        }
      }
    }
  }

  Future<void> _loadUserSettings() async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      final settingsRef = getFirestore()
          .collection('user_settings')
          .doc(user.uid);

      final settings = await settingsRef.get();
      if (settings.exists) {
        final data = settings.data()!;
        final sleepTxt = data['sleepTime'] ?? '23:00';
        final wakeTxt = data['wakeTime'] ?? '7:00';

        setState(() {
          _sleepTimeController.text = sleepTxt;
          _wakeTimeController.text = wakeTxt;
          sleepTime = _parseTime(sleepTxt);
          wakeTime = _parseTime(wakeTxt);
          _categories = List<String>.from(data['customCategories'] ?? []);
          _archivedCategories = List<String>.from(data['archivedCategories'] ?? []);
          _subCategories = (data['subCategories'] as Map<String, dynamic>? ?? {})
              .map((k, v) => MapEntry(k, List<String>.from(v as List)));
          _dedupCats();
          // ensure 'Sleep' is always present
          if (!_categories.contains('Sleep')) {
            _categories.insert(0,'Sleep');
          }
        });

        WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
        await _reconcileSleepEntriesForSelectedDate();
      } else {
        // Initialize with default settings if none exist
        await settingsRef.set({
          'sleepTime': '23:00',
          'wakeTime': '7:00',
          'customCategories': ['Work', 'Personal', 'Health', 'Other'],
          'archivedCategories': [],
          'lastUpdated': FieldValue.serverTimestamp(),
        });
        setState(() {
          _sleepTimeController.text = '23:00';
          _wakeTimeController.text = '7:00';
          _categories = List.from(kDefaultCategories);
          _archivedCategories = [];
          _dedupCats();
        });
        WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
        await _reconcileSleepEntriesForSelectedDate();
      }
    } catch (e) {
      final messenger = ScaffoldMessenger.maybeOf(context);
      messenger?.showSnackBar(
        const SnackBar(content: Text('Unable to load settings. Please try again later.')),
      );
    }
  }

  void _scrollToWakeTime() {
    if (wakeTime == null) return;
    const itemHeight = 120.0;
    final offset = wakeTime!.hour * itemHeight;
    if (_scrollController.hasClients) {
      _scrollController.jumpTo(offset.clamp(0, _scrollController.position.maxScrollExtent));
    } else {
      _pendingScrollOffset = offset;
    }
  }

  Future<void> _scrollToNow() async {
    final now = DateTime.now();
    final int hour = now.hour;
    final minute = (_splitHours.contains(hour) && now.minute >= 30) ? 30 : 0;
    final id = '${hour.toString().padLeft(2, '0')}:${minute.toString().padLeft(2, '0')}';

    void _doScroll() {
      final targetKey = _blockKeys[id];
      if (targetKey?.currentContext != null) {
        Scrollable.ensureVisible(
          targetKey!.currentContext!,
          duration: const Duration(milliseconds: 400),
          alignment: 0.0,
          curve: Curves.easeOut,
        );
        return;
      }
    }

    _doScroll();
    // already scheduled once for next frame below – keeps behaviour the same.
    WidgetsBinding.instance.addPostFrameCallback((_) => _doScroll());

    // If target not yet in tree we approximate offset, then refine after scroll.
    final targetKey = _blockKeys[id];
    if (targetKey?.currentContext != null) return;

    if (_scrollController.hasClients) {
      // Fallback approximation (includes extra space for section headers)
      const double itemHeight = 120.0;
      const double headerHeight = 48.0; // closer to actual ListTile height
      int headersBefore = 0;
      if (hour >= 6) headersBefore++;
      if (hour >= 12) headersBefore++;
      if (hour >= 18) headersBefore++;
      final double baseOffset = hour * itemHeight + (minute == 30 ? itemHeight / 2 : 0);
      final double offset = baseOffset + headersBefore * headerHeight;
      await _scrollController.animateTo(
        offset.clamp(0, _scrollController.position.maxScrollExtent),
        duration: const Duration(milliseconds: 400),
        curve: Curves.easeOut,
      );
      // After animation completes, attempt precise scroll again.
      _doScroll();
    }
  }

  bool _isSleepHour(int hour) {
    if (sleepTime == null || wakeTime == null) return false;
    final sleepHour = sleepTime!.hour;
    final wakeHour = wakeTime!.hour;
    if (sleepHour < wakeHour) {
      return hour >= sleepHour && hour < wakeHour;
    } else {
      // Sleep crosses midnight
      return hour >= sleepHour || hour < wakeHour;
    }
  }

  String _docId(DateTime dt) => DateFormat('yyyyMMdd_HHmm').format(dt);

  Future<void> _ensureSleepEntry(int hour, List<TimelineEntry> existingEntries) async {
    final alreadyExists = existingEntries.any((e) => e.startTime.hour == hour);
    if (alreadyExists) return;
    final userId = FirebaseAuth.instance.currentUser?.uid;
    if (userId == null) return;
    final start = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour);
    final newEntry = TimelineEntry(
      id: _docId(start),
      userId: userId,
      date: selectedDate,
      startTime: start,
      endTime: start.add(const Duration(hours: 1)),
      category: 'Sleep',
      notes: '',
    );
    final entriesColl = getFirestore()
        .collection('timeline_entries')
        .doc(userId)
        .collection('entries');
    await entriesColl.doc(newEntry.id).set(newEntry.toMap(), SetOptions(merge: true));
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Timeline'),
        actions: [
          ValueListenableBuilder<bool>(
            valueListenable: _showRetroNotifier,
            builder: (context, showRetro, _) => IconButton(
              icon: Icon(showRetro ? Icons.visibility : Icons.visibility_off),
              tooltip: showRetro ? 'Hide Retro' : 'Show Retro',
              onPressed: () => _showRetroNotifier.value = !showRetro,
            ),
          ),
          IconButton(
            icon: const Icon(Icons.bar_chart),
            tooltip: 'Analytics',
            onPressed: () => Navigator.pushNamed(context, '/analytics'),
          ),
          IconButton(
            icon: const Icon(Icons.access_time),
            tooltip: 'Jump to Now',
            onPressed: _scrollToNow,
          ),
          PopupMenuButton<String>(
            tooltip: 'Customize',
            onSelected: (value) async {
              switch (value) {
                case 'sleep':
                  _showSleepDialog(context);
                  break;
                case 'categories':
                  _showCategoriesDialog(context);
                  break;
                case 'habits':
                  Navigator.pushNamed(context, '/habits');
                  break;
                case 'template':
                  await Navigator.pushNamed(context, '/template');
                  if (mounted) setState(() {});
                  break;
              }
            },
            itemBuilder: (context) => [
              PopupMenuItem(
                value: 'sleep',
                child: ListTile(
                  leading: const Icon(Icons.bedtime),
                  title: const Text('Sleep timings'),
                ),
              ),
              PopupMenuItem(
                value: 'categories',
                child: ListTile(
                  leading: const Icon(Icons.label),
                  title: const Text('Categories'),
                ),
              ),
              PopupMenuItem(
                value: 'habits',
                child: ListTile(
                  leading: const Icon(Icons.check_circle_outline),
                  title: const Text('Habits'),
                ),
              ),
              PopupMenuItem(
                value: 'template',
                child: ListTile(
                  leading: const Icon(Icons.content_copy),
                  title: const Text('Template'),
                ),
              ),
            ],
          ),
        ],
      ),
      body: Column(
        children: [
          CalendarStrip(
            selectedDate: selectedDate,
            onDateSelected: (date) {
              // Save current offset is already handled by listener.
              setState(() {
                // clear controllers when switching date to avoid residue
                for (final c in _noteControllers.values) {
                  c.dispose();
                }
                _noteControllers.clear();
                _noteDebouncers.clear();

                _blockKeys.clear();

                selectedDate = date;
                _currentDateKey = DateFormat('yyyy-MM-dd').format(selectedDate);
                _loadDayComplete();
              });

              // After frame, jump to stored offset or fallback to wake time
              final key = DateFormat('yyyy-MM-dd').format(selectedDate);
              final double? saved = _offsetCache[key];
              if (saved != null) {
                _pendingScrollOffset = saved;
              } else {
                // fallback after list builds
                _pendingScrollOffset = null;
                WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
              }
            },
          ),
          ValueListenableBuilder<bool>(
            valueListenable: _dayCompleteNotifier,
            builder: (context, done, _) => CheckboxListTile(
              title: const Text('Day fully logged'),
              value: done,
              onChanged: (val){ if(val!=null) _setDayComplete(val); },
            ),
          ),
          ValueListenableBuilder<bool>(
            valueListenable: _habitsExpandedNotifier,
            builder: (context, expanded, _) => ExpansionTile(
              title: const Text('Habits'),
              initiallyExpanded: expanded,
              maintainState: true,
              onExpansionChanged: (val) => _habitsExpandedNotifier.value = val,
              children: [
                HabitTracker(date: selectedDate),
              ],
            ),
          ),
          Expanded(
            child: AnimatedSwitcher(
              duration: const Duration(milliseconds:300),
              switchInCurve: Curves.easeOut,
              switchOutCurve: Curves.easeIn,
              // Remove the outgoing child from the tree immediately to avoid
              // ScrollController and GlobalKey duplication.
              layoutBuilder: (currentChild, previousChildren) => currentChild ?? const SizedBox.shrink(),
              child: _buildTimelineBody(),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildTimelineBody() {
    return KeyedSubtree(
      // Different key per selected date allows AnimatedSwitcher to animatedly
      // replace the whole list when the date changes instead of a hard swap.
      key: ValueKey(_currentDateKey),
      child: StreamBuilder<QuerySnapshot>(
        stream: getFirestore()
            .collection('timeline_entries')
            .doc(FirebaseAuth.instance.currentUser?.uid ?? '')
            .collection('entries')
            .where('date', isEqualTo: DateFormat('yyyy-MM-dd').format(selectedDate))
            .snapshots(),
        builder: _buildTimelineStream,
      ),
    );
  }

  Widget _buildTimelineStream(BuildContext context, AsyncSnapshot<QuerySnapshot> snapshot) {
    if (snapshot.hasError) {
      return Center(child: Text('Error: ${snapshot.error}'));
    }
    if (snapshot.connectionState == ConnectionState.waiting) {
      return const Center(child: CircularProgressIndicator());
    }
    var entries = snapshot.data?.docs
            .map((doc) => TimelineEntry.fromFirestore(doc))
            .toList() ?? [];

    // If this snapshot only represents writes that originated from
    // this device (i.e. they are still pending confirmation from
    // the server) then re-use the previously rendered list instead
    // of forcing a full rebuild. This significantly reduces the
    // visible flicker that occurred while typing or selecting
    // categories because every local write triggered a rebuild of
    // the entire timeline.
    final bool onlyLocalUpdates = (snapshot.data != null &&
        snapshot.data!.docChanges.isNotEmpty &&
        snapshot.data!.docChanges.every((c) => c.doc.metadata.hasPendingWrites));

    if (onlyLocalUpdates) {
      // Apply the pending local changes to the cached list so the
      // UI still reflects the user's edits instantly.
      for (final change in snapshot.data!.docChanges) {
        final updated = TimelineEntry.fromFirestore(change.doc);
        final idx = _cachedEntries.indexWhere((e) => e.id == updated.id);
        switch (change.type) {
          case DocumentChangeType.removed:
            if (idx != -1) _cachedEntries.removeAt(idx);
            break;
          case DocumentChangeType.modified:
          case DocumentChangeType.added:
            if (idx == -1) {
              _cachedEntries.add(updated);
            } else {
              _cachedEntries[idx] = updated;
            }
            break;
        }
      }
      entries = _cachedEntries;
    } else {
      _cachedEntries = entries;
    }

    // update splitHours set based on presence of :30 entries
    _splitHours = entries
        .where((e) => e.startTime.minute == 30)
        .map((e) => e.startTime.hour)
        .toSet();

    // Always attempt to apply template (idempotent)
    _applyTemplateIfNeeded(entries);

    // Autofill sleep blocks only for today or future; leave past dates untouched
    final DateTime today = DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day);
    final bool isPastDate = selectedDate.isBefore(today);
    if (!isPastDate && sleepTime != null && wakeTime != null) {
      for (var hour = 0; hour < 24; hour++) {
        if (_isSleepHour(hour)) {
          _ensureSleepEntry(hour, entries);
        }
      }
    }

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_pendingScrollOffset!=null && _scrollController.hasClients) {
        final max=_scrollController.position.maxScrollExtent;
        _scrollController.jumpTo(_pendingScrollOffset!.clamp(0,max));
        _pendingScrollOffset=null;
      }
    });

    return ListView.builder(
      controller: _scrollController,
      itemCount: 24,
      itemBuilder: (context, hour) {
        // Retrieve any existing entries for this hour and minute markers
        String? _sectionTitle(int h){
          if(h==6) return 'Morning';
          if(h==12) return 'Afternoon';
          if(h==18) return 'Evening';
          return null;
        }

        TimelineEntry _blank(int minute) {
          final start=DateTime(selectedDate.year,selectedDate.month,selectedDate.day,hour,minute);
          return TimelineEntry(
            id: _docId(start),
            userId: FirebaseAuth.instance.currentUser?.uid ?? '',
            date: selectedDate,
            startTime: DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, minute),
            endTime: DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, minute).add(Duration(minutes: minute==0?60:30)),
            category: '',
            notes: '',
          );
        }

        final entry00 = entries.firstWhere(
          (e) => e.startTime.hour == hour && e.startTime.minute == 0,
          orElse: () => _blank(0),
        );

        final entry30 = _splitHours.contains(hour)
            ? entries.firstWhere(
                (e) => e.startTime.hour == hour && e.startTime.minute == 30,
                orElse: () => _blank(30),
              )
            : null;

        final bool isSleepRow = entry00.category == 'Sleep';
        final container= Container(
          margin: const EdgeInsets.symmetric(horizontal:8,vertical:3),
          decoration: BoxDecoration(
            color: isSleepRow ? Colors.blueGrey.withOpacity(0.04) : Theme.of(context).colorScheme.surfaceVariant,
            borderRadius: BorderRadius.circular(12),
            boxShadow: const [BoxShadow(color: Colors.black12, blurRadius:4, offset: Offset(0,2))],
          ),
          child: Column(
            children: [
              ListTile(
                title: Text(DateFormat('h a').format(DateTime(selectedDate.year,selectedDate.month,selectedDate.day,hour)), style: Theme.of(context).textTheme.titleSmall),
                trailing: IconButton(
                  icon: Icon(_splitHours.contains(hour) ? Icons.remove : Icons.call_split, color: Theme.of(context).colorScheme.primary),
                  onPressed: () => _toggleSplit(hour),
                ),
              ),
              _buildSubBlock(entry00, hour, 0),
              if (entry30 != null) _buildSubBlock(entry30, hour, 30),
            ],
          ),
        );

        final List<Widget> cardChildren=[];

        final section=_sectionTitle(hour);
        if(section!=null){
          cardChildren.add(Padding(
            padding: const EdgeInsets.symmetric(horizontal:16,vertical:8),
            child: Text(section,style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
          ));
        }

        cardChildren.add(container);
        return Column(children: cardChildren);
      },
    );
  }

  Future<void> _updateEntry(TimelineEntry entry, String category, String notes, {bool isPlan=false}) async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      final entriesColl = getFirestore()
          .collection('timeline_entries')
          .doc(user.uid)
          .collection('entries');

      final docId = _docId(entry.startTime);

      final fullEntry = TimelineEntry(
        id: docId,
        userId: user.uid,
        date: entry.date,
        startTime: entry.startTime,
        endTime: entry.endTime,
        planCategory: isPlan ? category : entry.planCategory,
        planNotes: isPlan ? notes : entry.planNotes,
        category: isPlan ? entry.category : category,
        notes: isPlan ? entry.notes : notes,
      );

      await entriesColl.doc(docId).set(fullEntry.toMap());
    } catch (e) {
      final messenger = ScaffoldMessenger.maybeOf(context);
      messenger?.showSnackBar(
        const SnackBar(content: Text('Unable to update entry. Please try again later.')),
      );
    }
  }

  Future<void> _showSleepDialog(BuildContext context) async {
    TimeOfDay? dialogSleep = sleepTime ?? (_sleepTimeController.text.isNotEmpty ? _parseTime(_sleepTimeController.text) : const TimeOfDay(hour: 23, minute: 0));
    TimeOfDay? dialogWake = wakeTime ?? (_wakeTimeController.text.isNotEmpty ? _parseTime(_wakeTimeController.text) : const TimeOfDay(hour: 7, minute: 0));

    final result = await showDialog(
      context: context,
      barrierDismissible: true,
      builder: (ctx) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return AlertDialog(
              title: const Text('Sleep Timings'),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      const Text('Sleep Time'),
                      TextButton(
                        onPressed: () async {
                          final t = await showTimePicker(
                            context: context,
                            initialTime: dialogSleep ?? const TimeOfDay(hour: 23, minute: 0),
                          );
                          if (t != null) {
                            setDialogState(() => dialogSleep = t);
                            _sleepTimeController.text = _fmt24(t);
                            await _saveSettings(refreshTimeline: true);
                          }
                        },
                        child: Text(dialogSleep?.format(context) ?? 'Set'),
                      ),
                    ],
                  ),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      const Text('Wake Time'),
                      TextButton(
                        onPressed: () async {
                          final t = await showTimePicker(
                            context: context,
                            initialTime: dialogWake ?? const TimeOfDay(hour: 7, minute: 0),
                          );
                          if (t != null) {
                            setDialogState(() => dialogWake = t);
                            _wakeTimeController.text = _fmt24(t);
                            await _saveSettings(refreshTimeline: true);
                          }
                        },
                        child: Text(dialogWake?.format(context) ?? 'Set'),
                      ),
                    ],
                  ),
                ],
              ),
              actions: [
                TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Close')),
              ],
            );
          },
        );
      },
    );

    // Rebuild timeline to reflect any category changes made inside the dialog
    if (mounted && result != null) {
      setState(() {});
    }
  }

  Future<void> _showCategoriesDialog(BuildContext context) async {
    final TextEditingController addCatController = TextEditingController();

    await showDialog(
      context: context,
      barrierDismissible: true,
      builder: (ctx) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return Dialog(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: SingleChildScrollView(
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      const Text('Categories', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
                      const SizedBox(height: 16),
                      Row(
                        children: [
                          Expanded(
                            child: TextField(
                              controller: addCatController,
                              decoration: const InputDecoration(labelText: 'Add category'),
                            ),
                          ),
                          IconButton(
                            icon: const Icon(Icons.add),
                            onPressed: () async {
                              final newCat = addCatController.text.trim();
                              if (newCat.isEmpty) return;
                              setDialogState(() {
                                _categories.add(newCat);
                                _archivedCategories.remove(newCat); // ensure it's active
                                _dedupCats();
                              });
                              addCatController.clear();
                              await _saveSettings(refreshTimeline: true);
                            },
                          ),
                        ],
                      ),
                      const SizedBox(height: 8),
                      Container(
                        constraints: const BoxConstraints(maxHeight: 300),
                        child: ListView.builder(
                          shrinkWrap: true,
                          itemCount: _categories.length,
                          itemBuilder: (context, index) {
                            final parent = _categories[index];
                            final subs = _subCategories[parent] ?? [];
                            final isDefault = _protectedCategories.contains(parent);
                            final TextEditingController subCtrl = TextEditingController();
                            return ExpansionTile(
                              title: Text(_displayLabel(parent)),
                              trailing: isDefault
                                  ? null
                                  : IconButton(
                                      icon: const Icon(Icons.delete),
                                      onPressed: () async {
                                        setDialogState(() {
                                          _categories.remove(parent);
                                          if (!_archivedCategories.contains(parent)) {
                                            _archivedCategories.add(parent);
                                          }
                                          // keep subCategories map intact so past subs remain
                                          _dedupCats();
                                        });
                                        await _saveSettings(refreshTimeline: true);
                                      },
                                    ),
                              children: [
                                ...subs.map((s) => Padding(
                                      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 4),
                                      child: Row(
                                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                        children: [
                                          Text(s),
                                          IconButton(
                                            icon: const Icon(Icons.delete_outline),
                                            onPressed: () async {
                                              await _removeSubCategory(parent, s);
                                              setDialogState(() {});
                                            },
                                          ),
                                        ],
                                      ),
                                    )),
                                Padding(
                                  padding: const EdgeInsets.symmetric(horizontal: 24),
                                  child: Row(
                                    children: [
                                      Expanded(
                                        child: TextField(
                                          controller: subCtrl,
                                          decoration: const InputDecoration(labelText: 'Add sub-category'),
                                        ),
                                      ),
                                      IconButton(
                                        icon: const Icon(Icons.add_circle_outline),
                                        onPressed: () async {
                                          final sub = subCtrl.text.trim();
                                          if (sub.isEmpty) return;
                                          await _addSubCategory(parent, sub);
                                          subCtrl.clear();
                                          setDialogState(() {});
                                        },
                                      ),
                                    ],
                                  ),
                                ),
                              ],
                            );
                          },
                        ),
                      ),
                      const SizedBox(height: 8),
                      TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Close')),
                    ],
                  ),
                ),
              ),
            );
          },
        );
      },
    );
  }

  Future<void> _saveSettings({bool refreshTimeline = true}) async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      final settingsRef = getFirestore()
          .collection('user_settings')
          .doc(user.uid);

      _dedupCats();

      // Determine if times actually changed (compare by hour/minute not string)
      TimeOfDay _toTod(String s) => _parseTime(s);

      final prevSleep = sleepTime ?? _toTod(_sleepTimeController.text);
      final prevWake = wakeTime ?? _toTod(_wakeTimeController.text);
      final newSleep = _toTod(_sleepTimeController.text);
      final newWake = _toTod(_wakeTimeController.text);
      final bool timesChanged = prevSleep != newSleep || prevWake != newWake;

      await settingsRef.set({
        'sleepTime': _sleepTimeController.text,
        'wakeTime': _wakeTimeController.text,
        'customCategories': _categories,
        'archivedCategories': _archivedCategories,
        'subCategories': _subCategories,
        'lastUpdated': FieldValue.serverTimestamp(),
      }, SetOptions(merge: true));

      // refresh local vars
      if (refreshTimeline && mounted) {
        setState(() {
          if (timesChanged) {
            sleepTime = newSleep;
            wakeTime = newWake;
          }
          // ensure categories list refreshes in timeline & dropdown
          _categories = List<String>.from(_categories);
        });

        if (timesChanged) {
          // after rebuild, scroll
          WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToWakeTime());
        }
      }

      if (timesChanged) {
        await _reconcileSleepEntriesForSelectedDate();
      }

      ScaffoldMessenger.maybeOf(context)?.showSnackBar(
        const SnackBar(content: Text('Settings saved')),
      );
    } catch (e) {
      ScaffoldMessenger.maybeOf(context)?.showSnackBar(
        const SnackBar(content: Text('Unable to save settings. Please try again later.')),
      );
    }
  }

  String _fmt24(TimeOfDay t) => '${t.hour.toString().padLeft(2, '0')}:${t.minute.toString().padLeft(2, '0')}';

  void _dedupCats() {
    _categories = _categories.toSet().toList();
    _archivedCategories = _archivedCategories.toSet().toList();
  }

  Future<void> _toggleSplit(int hour) async {
    final userId = FirebaseAuth.instance.currentUser?.uid;
    if (userId == null) return;
    // No need to capture offset; we will not rebuild the whole list.
    final entriesColl = getFirestore()
        .collection('timeline_entries')
        .doc(userId)
        .collection('entries');

    final halfStart = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, 30);
    final halfDocId = _docId(halfStart);

    if (_splitHours.contains(hour)) {
      // MERGE -> remove 30-minute entry
      await entriesColl.doc(halfDocId).delete();

      _splitHours.remove(hour);
      _cachedEntries.removeWhere((e) => e.id == halfDocId);

      final k = _noteKey(hour, 30);
      _noteControllers.remove(k)?.dispose();
      _noteDebouncers.remove(k)?.cancel();
    } else {
      // SPLIT -> add blank 30-minute entry
      final newEntry = TimelineEntry(
        id: halfDocId,
        userId: userId,
        date: selectedDate,
        startTime: halfStart,
        endTime: halfStart.add(const Duration(minutes: 30)),
        category: '',
        notes: '',
      );
      await entriesColl.doc(halfDocId).set(newEntry.toMap());

      _splitHours.add(hour);
      _cachedEntries.add(newEntry);
    }

    // Rebuild only if the widget is still in the tree; this redraws the two
    // affected rows without resetting scroll position.
    if (mounted) setState(() {});
  }

  String _noteKey(int hour, int minute) => '${hour.toString().padLeft(2,'0')}:${minute.toString().padLeft(2,'0')}';

  Widget _buildSubBlock(TimelineEntry entry, int hour, int minute) {
    final keyStr = _noteKey(hour, minute);
    final subKey = _blockKeys.putIfAbsent(keyStr, () => GlobalKey());
    final key = keyStr;
    final controller = _noteControllers.putIfAbsent(key, () => TextEditingController(text: entry.notes));
    // keep controller text in sync if backend changed (but avoid disrupting typing)
    if (controller.text != entry.notes && !_noteDebouncers.containsKey(key)) {
      controller.text = entry.notes;
      controller.selection = TextSelection.collapsed(offset: controller.text.length);
    }

    // Pre-compute flattened categories once to avoid redundant work and help with value validation
    final availableCategories = _flattenCats();
    // Always ensure current entry's category is available for its own dropdown
    void _ensureValue(String v){if(v.isNotEmpty && !availableCategories.contains(v)){availableCategories.add(v);} }
    _ensureValue(entry.category);
    _ensureValue(entry.planCategory);

    final String? dropdownValue =
        (entry.category.isNotEmpty && availableCategories.contains(entry.category))
            ? entry.category
            : null;

    final planNoteCtrl = _noteControllers.putIfAbsent('p_'+key, ()=> TextEditingController(text: entry.planNotes));
    if(planNoteCtrl.text!=entry.planNotes && !_noteDebouncers.containsKey('p_'+key)){
      planNoteCtrl.text=entry.planNotes;
      planNoteCtrl.selection=TextSelection.collapsed(offset:planNoteCtrl.text.length);
    }

    final retroNoteCtrl = controller; // existing

    Widget planColumn = Expanded(
      child: Container(
        decoration: BoxDecoration(
          color: _planBg(context),
          borderRadius: _showRetro
              ? const BorderRadius.only(topLeft: Radius.circular(8), bottomLeft: Radius.circular(8))
              : BorderRadius.circular(8),
        ),
        padding: const EdgeInsets.all(8),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children:[
            DropdownButton<String>(
              value: entry.planCategory.isEmpty?null:entry.planCategory,
              hint: const Text('Plan'),
              isExpanded: true,
              items: availableCategories.map((c)=>DropdownMenuItem(value:c,child:Text(_displayLabel(c), overflow: TextOverflow.ellipsis))).toList(),
              onChanged:(val){if(val!=null)_updateEntry(entry,val,entry.planNotes,isPlan:true);},
            ),
            TextField(
              controller: planNoteCtrl,
              maxLines:null,
              decoration: const InputDecoration(hintText:'Notes',border:InputBorder.none),
              onChanged:(val){
                _noteDebouncers['p_'+key]?.cancel();
                _noteDebouncers['p_'+key]=Timer(const Duration(milliseconds:500),(){_updateEntry(entry, entry.planCategory, val,isPlan:true);_noteDebouncers.remove('p_'+key);});
              },
            ),
          ]),
        ));

    Widget retroColumn = Expanded(
      child: Container(
        decoration: BoxDecoration(
          color: _retroBg(context),
          borderRadius: const BorderRadius.only(topRight: Radius.circular(8), bottomRight: Radius.circular(8)),
        ),
        padding: const EdgeInsets.all(8),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children:[
            DropdownButton<String>(
              value: dropdownValue,
              hint: const Text('Retro'),
              isExpanded: true,
              items: availableCategories.map((c)=>DropdownMenuItem(value:c,child:Text(_displayLabel(c), overflow: TextOverflow.ellipsis))).toList(),
              onChanged:(val){if(val!=null)_updateEntry(entry,val,entry.notes);},
            ),
            TextField(
              controller: retroNoteCtrl,
              maxLines:null,
              decoration: const InputDecoration(hintText:'Notes',border:InputBorder.none),
              onChanged:(val){
                _noteDebouncers[key]?.cancel();
                _noteDebouncers[key]=Timer(const Duration(milliseconds:500),(){_updateEntry(entry, entry.category, val);_noteDebouncers.remove(key);});
              },
            ),
          ]),
        ));

    return KeyedSubtree(
      key: subKey,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
        child: ValueListenableBuilder<bool>(
          valueListenable: _showRetroNotifier,
          builder: (context, showRetro, _) => Row(
            children: [
              planColumn,
              if (showRetro) const SizedBox(width: 2),
              if (showRetro) retroColumn,
            ],
          ),
        ),
      ),
    );
  }

  String _dateStr(DateTime d)=>DateFormat('yyyy-MM-dd').format(d);

  Future<void> _loadDayComplete() async{
    final uid=FirebaseAuth.instance.currentUser?.uid; if(uid==null) return;
    final doc=await getFirestore().collection('daily_logs').doc(uid).collection('logs').doc(_dateStr(selectedDate)).get();
    _dayCompleteNotifier.value = doc.exists && (doc.data()?['complete']==true);
  }

  Future<void> _setDayComplete(bool val) async{
    final uid=FirebaseAuth.instance.currentUser?.uid; if(uid==null) return;
    final ref=getFirestore().collection('daily_logs').doc(uid).collection('logs').doc(_dateStr(selectedDate));
    if(val){
      await ref.set({'date':_dateStr(selectedDate),'complete':true,'lastUpdated':FieldValue.serverTimestamp()});
    }else{
      await ref.delete();
    }
    _dayCompleteNotifier.value = val;
  }

  // ---------- Sub-category helpers ----------
  Future<void> _addSubCategory(String parent, String sub) async {
    if (sub.trim().isEmpty) return;
    if (!_categories.contains(parent)) {
      _categories.add(parent);
    }
    final list = _subCategories[parent] ?? <String>[];
    if (!list.contains(sub)) {
      list.add(sub);
      _subCategories[parent] = list;
      await _saveSettings(refreshTimeline: true);

      final double offset=_scrollController.hasClients?_scrollController.offset:0;
      if (mounted) setState(() {});
      WidgetsBinding.instance.addPostFrameCallback((_){
        if(_scrollController.hasClients){
          _scrollController.jumpTo(offset.clamp(0,_scrollController.position.maxScrollExtent));
        }
      });
    }
  }

  Future<void> _removeSubCategory(String parent, String sub) async {
    final list = _subCategories[parent];
    if (list == null) return;
    list.remove(sub);
    if (list.isEmpty) {
      _subCategories.remove(parent);
    } else {
      _subCategories[parent] = list;
    }
    await _saveSettings(refreshTimeline: true);
    final double offset=_scrollController.hasClients?_scrollController.offset:0;
    if (mounted) setState(() {});
    WidgetsBinding.instance.addPostFrameCallback((_){
      if(_scrollController.hasClients){
        _scrollController.jumpTo(offset.clamp(0,_scrollController.position.maxScrollExtent));
      }
    });
  }

  Future<void> _applyTemplateIfNeeded(List<TimelineEntry> currentEntries) async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;
    final dateStr = _dateStr(selectedDate);
    // Only today or future
    final DateTime today = DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day);
    if (selectedDate.isBefore(today)) return;
    if (_dayComplete) return; // don't overwrite completed day

    // fetch template docs
    final snap = await getFirestore()
        .collection('template_entries')
        .doc(uid)
        .collection('entries')
        .get();
    if (snap.docs.isEmpty) {
      return; // no template yet
    }

    final Map<String, TimelineEntry> existingMap = {
      for (var e in currentEntries) _noteKey(e.startTime.hour, e.startTime.minute): e
    };

    final batch = getFirestore().batch();
    final entriesColl = getFirestore().collection('timeline_entries').doc(uid).collection('entries');

    for (final doc in snap.docs) {
      final hour = int.parse(doc.id.substring(0, 2));
      final minute = int.parse(doc.id.substring(2));
      final key = _noteKey(hour, minute);
      final tmplPlanCat = doc['planCategory'] ?? doc['category'] ?? '';
      final tmplPlanNotes = doc['planNotes'] ?? doc['notes'] ?? '';
      final tmplRetroCat = doc['category'] ?? tmplPlanCat;
      final tmplRetroNotes = doc['notes'] ?? tmplPlanNotes;

      if (existingMap.containsKey(key)) {
        final existing = existingMap[key]!;
        final Map<String,dynamic> upd={};
        if(existing.planCategory.isEmpty){
          upd['planCategory']=tmplPlanCat; upd['planNotes']=tmplPlanNotes; }
        if(existing.category.isEmpty){
          upd['category']=tmplRetroCat; upd['notes']=tmplRetroNotes; }
        if(upd.isNotEmpty){batch.update(entriesColl.doc(existing.id),upd);}        
        continue;
      }

      final start = DateTime(selectedDate.year, selectedDate.month, selectedDate.day, hour, minute);
      final newEntry = TimelineEntry(
        id: _docId(start),
        userId: uid,
        date: selectedDate,
        startTime: start,
        endTime: start.add(Duration(minutes: minute == 0 ? 60 : 30)),
        planCategory: tmplPlanCat,
        planNotes: tmplPlanNotes,
        category: tmplRetroCat,
        notes: tmplRetroNotes,
      );
      batch.set(entriesColl.doc(newEntry.id), newEntry.toMap());
    }
    await batch.commit();
  }

  List<String> _flattenCats() {
    final flatSet = <String>{};
    void addParent(String parent) {
      flatSet.add(parent);
      final subs = _subCategories[parent] ?? [];
      for (final s in subs) {
        flatSet.add('$parent / $s');
      }
    }

    for (final parent in _categories) {
      addParent(parent);
    }

    final DateTime today = DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day);
    if (selectedDate.isBefore(today)) {
      for (final parent in _archivedCategories) {
        addParent(parent);
      }
    }

    return flatSet.toList();
  }
} 